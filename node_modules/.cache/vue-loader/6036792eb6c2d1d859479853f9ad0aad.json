{"remainingRequest":"/home/robert/Desktop/Visualisations2020/layouttest-sans-eslint/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/robert/Desktop/Visualisations2020/layouttest-sans-eslint/src/components/Orbits.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/robert/Desktop/Visualisations2020/layouttest-sans-eslint/src/components/Orbits.vue","mtime":1596815784997},{"path":"/home/robert/Desktop/Visualisations2020/layouttest-sans-eslint/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/robert/Desktop/Visualisations2020/layouttest-sans-eslint/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/robert/Desktop/Visualisations2020/layouttest-sans-eslint/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/robert/Desktop/Visualisations2020/layouttest-sans-eslint/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KDQpleHBvcnQgZGVmYXVsdCB7DQogICAgbmFtZTogJ2l2LW9yYml0cycsDQogICAgcHJvcHM6IHsNCiAgICAgICAgbW91c2U6IHsNCiAgICAgICAgICAgIGRlZmF1bHQ6IHsNCiAgICAgICAgICAgICAgICB4OiB1bmRlZmluZWQsDQogICAgICAgICAgICAgICAgeTogdW5kZWZpbmVkDQogICAgICAgICAgICB9DQogICAgICAgIH0sDQogICAgICAgIGFuaW1hdGlvblNwZWVkOiB7DQogICAgICAgICAgICBkZWZhdWx0OiAxDQogICAgICAgIH0sDQogICAgICAgIHZlbG9jaXR5U2VsZWN0OiB7DQogICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgICAgICB9LA0KICAgICAgICBzdW5SYWRpdXM6IHsNCiAgICAgICAgICAgIGRlZmF1bHQ6IDIwDQogICAgICAgIH0sDQogICAgICAgIHRvdWNoU2VsZWN0OiB7DQogICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgICAgICB9LA0KICAgICAgICBpbml0aWFsVG91Y2hQb3M6ew0KICAgICAgICAgICAgZGVmYXVsdDogew0KICAgICAgICAgICAgICAgIHg6IHVuZGVmaW5lZCwNCiAgICAgICAgICAgICAgICB5OiB1bmRlZmluZWQNCiAgICAgICAgICAgIH0NCiAgICAgICAgfSwNCiAgICAgICAgY3VycmVudFRvdWNoUG9zOnsNCiAgICAgICAgICAgIGRlZmF1bHQ6IHsNCiAgICAgICAgICAgICAgICB4OiB1bmRlZmluZWQsDQogICAgICAgICAgICAgICAgeTogdW5kZWZpbmVkDQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9LA0KICAgIG1ldGhvZHM6IHsNCiAgICAgICAgdG91Y2hPbihldmVudCl7DQogICAgICAgICAgICB0aGlzLmluaXRpYWxUb3VjaFBvcy54ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDsNCiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFRvdWNoUG9zLnkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZOw0KICAgICAgICAgICAgY29uc29sZS5sb2coJ3RvdWNoT24nKTsNCiAgICAgICAgfSwNCiAgICAgICAgdG91Y2hPZmYoKXsNCiAgICAgICAgICAgIHRoaXMudG91Y2hTZWxlY3QgPSBmYWxzZTsNCiAgICAgICAgICAgIHRoaXMuY3VycmVudFRvdWNoUG9zLnggPSB1bmRlZmluZWQ7DQogICAgICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaFBvcy55ID0gdW5kZWZpbmVkOw0KICAgICAgICAgICAgdGhpcy5pbml0aWFsVG91Y2hQb3MueCA9IHVuZGVmaW5lZDsNCiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFRvdWNoUG9zLnkgPSB1bmRlZmluZWQ7DQogICAgICAgICAgICBjb25zb2xlLmxvZygndG91Y2hPZmYnKTsNCiAgICAgICAgfSwNCiAgICAgICAgdG91Y2hDaGFuZ2UoZXZlbnQpew0KICAgICAgICAgICAgdGhpcy50b3VjaFNlbGVjdCA9IHRydWU7DQogICAgICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaFBvcy54ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDsNCiAgICAgICAgICAgIHRoaXMuY3VycmVudFRvdWNoUG9zLnkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZOw0KICAgICAgICB9LA0KICAgICAgICBtb3VzZU92ZXIoZXZlbnQpew0KICAgICAgICAgICAgdGhpcy5tb3VzZS54ID0gZXZlbnQueDsNCiAgICAgICAgICAgIHRoaXMubW91c2UueSA9IGV2ZW50Lnk7DQogICAgICAgIH0sDQogICAgICAgIG1vdXNlTGVhdmUoKXsNCiAgICAgICAgICAgIHRoaXMubW91c2UueCA9IHVuZGVmaW5lZDsNCiAgICAgICAgICAgIHRoaXMubW91c2UueSA9IHVuZGVmaW5lZDsNCiAgICAgICAgfSwNCiAgICAgICAgYWN0aXZhdGVTZWxlY3QoKXsNCiAgICAgICAgICAgIHRoaXMudmVsb2NpdHlTZWxlY3QgPSB0cnVlOw0KICAgICAgICB9LA0KICAgICAgICBjYW5jZWxTZWxlY3QoKXsNCiAgICAgICAgICAgIHRoaXMudmVsb2NpdHlTZWxlY3QgPSBmYWxzZTsNCiAgICAgICAgfSwNCg0KICAgIH0sDQogICAgbW91bnRlZCgpew0KICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzJyk7DQogICAgICAgIGxldCBwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7DQogICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5vZmZzZXRXaWR0aDsNCiAgICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5vZmZzZXRIZWlnaHQ7DQogICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOw0KDQogICAgICAgIGxldCB2bSA9IHRoaXM7DQogICAgICAgIGxldCBtb3VzZVggPSB0aGlzLm1vdXNlLnggLSByZWN0LmxlZnQ7DQogICAgICAgIGxldCBtb3VzZVkgPSB0aGlzLm1vdXNlLnkgLSByZWN0LnRvcDsNCiAgICAgICAgbGV0IGN1cnJlbnRUb3VjaFggPSB0aGlzLmN1cnJlbnRUb3VjaFBvcy54IC0gcmVjdC5sZWZ0Ow0KICAgICAgICBsZXQgY3VycmVudFRvdWNoWSA9IHRoaXMuY3VycmVudFRvdWNoUG9zLnkgLSByZWN0LnRvcDsNCiAgICAgICAgLy8gbGV0IGluaXRpYWxUb3VjaFggPSB0aGlzLmluaXRpYWxUb3VjaFBvcy54IC0gcmVjdC5sZWZ0Ow0KICAgICAgICAvLyBsZXQgaW5pdGlhbFRvdWNoWSA9IHRoaXMuaW5pdGlhbFRvdWNoUG9zLnkgLSByZWN0LnRvcDsNCg0KDQogICAgICAgIGxldCBjID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7DQogICAgICAgIC8vY2VudHJlIGFib3V0IHg9MCwgeT0wDQogICAgICAgIGMudHJhbnNsYXRlKGNhbnZhcy53aWR0aC8yLCBjYW52YXMuaGVpZ2h0LzIpOw0KDQoNCiAgICAgICAgZnVuY3Rpb24gcm90YXRlU2hhcGUoYW5nbGUsIGNlbnRyZSwgcG9pbnRzKXsNCiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYW5nbGUsIGNlbnRyZSwgcG9pbnRzKTsNCiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IFtwb2ludHNbaV1bMF0qTWF0aC5jb3MoYW5nbGUpIC0gcG9pbnRzW2ldWzFdKk1hdGguc2luKGFuZ2xlKSwgcG9pbnRzW2ldWzBdKk1hdGguc2luKGFuZ2xlKSArIHBvaW50c1tpXVsxXSpNYXRoLmNvcyhhbmdsZSldOw0KICAgICAgICAgICAgICAgIHBvaW50c1tpXVswXSA9IGNlbnRyZVswXSArIHBvaW50c1tpXVswXTsNCiAgICAgICAgICAgICAgICBwb2ludHNbaV1bMV0gPSBjZW50cmVbMV0gKyBwb2ludHNbaV1bMV07DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gcG9pbnRzOw0KICAgICAgICB9DQoNCiAgICAgICAgDQogICAgICAgIGZ1bmN0aW9uIEJhbGwoeCwgeSwgZGVmYXVsdFJhZGl1cywgZHgsIGR5KSB7DQogICAgICAgICAgICB0aGlzLnggPSB4Ow0KICAgICAgICAgICAgdGhpcy55ID0geTsNCiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gZGVmYXVsdFJhZGl1czsNCiAgICAgICAgICAgIHRoaXMucGF0aEluZGV4ID0gMDsNCiAgICAgICAgICAgIHRoaXMudmVsb2NpdHlTZWxlY3QgPSBmYWxzZTsNCiAgICAgICAgICAgIHRoaXMudG91Y2hJbnRlcmZhY2UgPSBmYWxzZTsNCiAgICAgICAgICAgIHRoaXMudGltZVNpbmNlQ2xpY2sgPSAxMDsNCiAgICAgICAgICAgIHRoaXMuYnV0dG9uU3RlcCA9IDAuMTsNCiAgICAgICAgICAgIHRoaXMuYXJyb3dDb25maXJtZWQgPSBmYWxzZTsNCiAgICAgICAgICAgIGxldCBuZXdQYXRoID0gZmFsc2U7DQoNCiAgICAgICAgICAgIGlmKGR4ID09IHVuZGVmaW5lZCB8fCBkeSA9PSB1bmRlZmluZWQpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBhbGwgb3JiaXQgaW4gY2lyY3VsYXIgb3JiaXRzIGluIHNhbWUgZGlyZWN0aW9uIGluaXRpYWxseSANCiAgICAgICAgICAgICAgICB0aGlzLmR4ID0gMDsNCiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gMDsNCg0KICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtYXNzQ2VudHJlcy5sZW5ndGg7IGkrKyl7ICANCiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gTWF0aC5wb3coTWF0aC5wb3codGhpcy54LW1hc3NDZW50cmVzW2ldWzBdICwgMikgKyBNYXRoLnBvdyh0aGlzLnktbWFzc0NlbnRyZXNbaV1bMV0sIDIpLCAwLjUpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmR5ICs9IC1pbml0aWFsVmVsKm1hc3NDZW50cmVzW2ldWzJdKk1hdGguYWJzKE1hdGgucG93KHRoaXMuZGlzdCAsIC0yKSkqKG1hc3NDZW50cmVzW2ldWzBdLXRoaXMueCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtYXNzQ2VudHJlcy5sZW5ndGg7IGkrKyl7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IE1hdGgucG93KE1hdGgucG93KHRoaXMueC1tYXNzQ2VudHJlc1tpXVswXSAsIDIpICsgTWF0aC5wb3codGhpcy55LW1hc3NDZW50cmVzW2ldWzFdLCAyKSwgMC41KTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5keCArPSBpbml0aWFsVmVsKm1hc3NDZW50cmVzW2ldWzJdKk1hdGguYWJzKE1hdGgucG93KHRoaXMuZGlzdCAsIC0yKSkqKG1hc3NDZW50cmVzW2ldWzFdLXRoaXMueSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgICB0aGlzLmR4ID0gZHg7DQogICAgICAgICAgICAgICAgdGhpcy5keSA9IGR5Ow0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICB0aGlzLnBhdGhFbmVyZ2llcyA9IGZ1bmN0aW9uKCl7DQogICAgICAgICAgICAgICAgdGhpcy5wYXRoR3JhdlBvdCA9IFtdOw0KICAgICAgICAgICAgICAgIHRoaXMucGF0aEFuZ01vbSA9IFtdOw0KICAgICAgICAgICAgICAgIHRoaXMucGF0aEVmZlBvdCA9IFtdOw0KICAgICAgICAgICAgICAgIHRoaXMudG90RSA9IDA7DQoNCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoQ29vcmRzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgLy8gVGFraW5nIG1hc3Mgb2Ygb3JiaXRpbmcgb2JqZWN0IGFzIDENCiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gTWF0aC5wb3coTWF0aC5wb3codGhpcy5wYXRoQ29vcmRzW2ldWzBdLW1hc3NDZW50cmVzWzBdWzBdICwgMikgKyBNYXRoLnBvdyh0aGlzLnBhdGhDb29yZHNbaV1bMV0tbWFzc0NlbnRyZXNbMF1bMV0sIDIpLCAwLjUpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhHcmF2UG90LnB1c2goLWluaXRpYWxWZWwqbWFzc0NlbnRyZXNbMF1bMl0vKHRoaXMuZGlzdCo0Kk1hdGguUEkpKTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQW5nTW9tLnB1c2goTWF0aC5wb3coTWF0aC5wb3codGhpcy5wYXRoVmVsc1tpXVswXSwyKSArIE1hdGgucG93KHRoaXMucGF0aFZlbHNbaV1bMV0sMiksMC41KSAqIHRoaXMuZGlzdCAvbWFzc0NlbnRyZXNbMF1bMl0pOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhFZmZQb3QucHVzaCh0aGlzLnBhdGhHcmF2UG90W2ldICsgdGhpcy5wYXRoQW5nTW9tW2ldKTsNCiAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICB0aGlzLnRvdEUgPSAwLjUqTWF0aC5wb3codGhpcy5wYXRoQW5nTW9tWzBdICwyKSArIHRoaXMucGF0aEdyYXZQb3RbMF07DQogICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RvdGFsIGVuZXJneSA9ICcsdGhpcy50b3RFKTsNCiAgICAgICAgICAgICAgICAvL3RoaXMudG90RSA9IDAuNSooTWF0aC5wb3codGhpcy5keCwyKSArIE1hdGgucG93KHRoaXMuZHksMikpICsgbWFzc0NlbnRyZXNbaV1bMl0qTWF0aC5hYnModGhpcy5kaXN0LCAtMSk7DQogICAgICAgICAgICAgICAgdm0uJGVtaXQoJ2VuZXJnaWVzJywgW3RoaXMucGF0aEFuZ01vbSwgdGhpcy5wYXRoR3JhdlBvdCwgdGhpcy5wYXRoRWZmUG90LHRoaXMudG90RV0pOw0KICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlbWl0dGVkJyk7DQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGR4LCBkeSkgIHsNCiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFBvcyA9IFt0aGlzLngsIHRoaXMueV07DQogICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRWZWwgPSBbdGhpcy5keCwgdGhpcy5keV07DQogICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy52ZWxvY2l0eVNlbGVjdCk7DQogICAgICAgICAgICAgICAgaWYodGhpcy52ZWxvY2l0eVNlbGVjdCB8fCBuZXdQYXRoKXsNCiAgICAgICAgICAgICAgICAgICAgaWYoaXNOYU4oZHgpIHx8IGlzTmFOKGR5KSl7DQogICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmVsID0gW3RoaXMueCwgdGhpcy55XTsNCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZWwgPSBbZHgsIGR5XTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgDQogICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFZlbHMgPSBbXTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQ29vcmRzID0gW107DQogICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUgPSAxOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0aW9ucyA9IDA7DQogICAgICAgICAgICAgICAgdGhpcy5uZXdDb29yZHMgPSBbXTsNCiAgICAgICAgICAgICAgICB0aGlzLm5ld1ZlbHMgPSBbXTsNCiAgICAgICAgICAgICAgICBsZXQgc3RlcFNpemUgPSAxOw0KICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VkUGF0aCA9IHRydWU7DQogICAgICAgICAgICAgICAgbGV0IHJldmVyc2VNdWx0aXBsaWVyID0gMTsNCiAgICAgICAgICAgICAgICB0aGlzLm1heEl0ZXJhdGlvbnMgPSAyMDAwMDsNCiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncGF0aCBkcmF3aW5nJyk7DQoNCiAgICAgICAgICAgICAgICB3aGlsZShNYXRoLnBvdygoTWF0aC5wb3codGhpcy54LWN1cnJlbnRQb3NbMF0sIDIpICsgTWF0aC5wb3codGhpcy55LWN1cnJlbnRQb3NbMV0sMikpLDAuNSkgPiAxIHx8IGl0ZXJhdGlvbnMgPCAxMDApew0KDQogICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NbMF0gKz0gY3VycmVudFZlbFswXSAqIHJldmVyc2VNdWx0aXBsaWVyICogc3RlcFNpemU7DQogICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NbMV0gKz0gY3VycmVudFZlbFsxXSAqIHJldmVyc2VNdWx0aXBsaWVyICogc3RlcFNpemU7DQoNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG1hc3NDZW50cmVzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5wb3coTWF0aC5wb3coY3VycmVudFBvc1swXS1tYXNzQ2VudHJlc1tpXVswXSAsIDIpICsgTWF0aC5wb3coY3VycmVudFBvc1sxXS1tYXNzQ2VudHJlc1tpXVsxXSwgMiksIDAuNSk7DQoNCiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZWxbMF0gPSBjdXJyZW50VmVsWzBdICsgcmV2ZXJzZU11bHRpcGxpZXIgKiBtYXNzQ2VudHJlc1tpXVsyXSpNYXRoLmFicyhNYXRoLnBvdyhkaXN0ICwgLTMpKSoobWFzc0NlbnRyZXNbaV1bMF0tY3VycmVudFBvc1swXSk7DQogICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmVsWzFdID0gY3VycmVudFZlbFsxXSArIHJldmVyc2VNdWx0aXBsaWVyICogbWFzc0NlbnRyZXNbaV1bMl0qTWF0aC5hYnMoTWF0aC5wb3coZGlzdCAsIC0zKSkqKG1hc3NDZW50cmVzW2ldWzFdLWN1cnJlbnRQb3NbMV0pOw0KICAgICAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VkUGF0aCl7DQogICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnZlbG9jaXR5U2VsZWN0IHx8IG5ld1BhdGgpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Q29vcmRzLnB1c2goY3VycmVudFBvcy5zbGljZSgpKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZlbHMucHVzaChjdXJyZW50VmVsLnNsaWNlKCkpOw0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aENvb3Jkcy5wdXNoKGN1cnJlbnRQb3Muc2xpY2UoKSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoVmVscy5wdXNoKGN1cnJlbnRWZWwuc2xpY2UoKSk7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIH0gZWxzZXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudmVsb2NpdHlTZWxlY3QgfHwgbmV3UGF0aCl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdDb29yZHMudW5zaGlmdChjdXJyZW50UG9zLnNsaWNlKCkpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmVscy51bnNoaWZ0KGN1cnJlbnRWZWwuc2xpY2UoKSk7DQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2V7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQ29vcmRzLnVuc2hpZnQoY3VycmVudFBvcy5zbGljZSgpKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhWZWxzLnVuc2hpZnQoY3VycmVudFZlbC5zbGljZSgpKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMgKz0gMTsNCiAgICAgICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgIC8vRHJhdyByZXZlcnNlIHBhdGggZm9yIG9wZW4gcGF0aA0KICAgICAgICAgICAgICAgICAgICBpZihpdGVyYXRpb25zID4gdGhpcy5tYXhJdGVyYXRpb25zIHx8IE1hdGgucG93KE1hdGgucG93KGN1cnJlbnRQb3NbMF0sMikgKyBNYXRoLnBvdyhjdXJyZW50UG9zWzFdLDIpLDAuNSkgPCB2bS5zdW5SYWRpdXMpew0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhJdGVyYXRpb25zID0gaXRlcmF0aW9uczsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VkUGF0aCA9IGZhbHNlOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy52ZWxvY2l0eVNlbGVjdCB8fCBuZXdQYXRoKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gW3RoaXMueCwgdGhpcy55XTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmVsID0gW2R4LCBkeV07DQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBbdGhpcy54LCB0aGlzLnldOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZWwgPSBbdGhpcy5keCwgdGhpcy5keV07DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25zID0gMDsNCiAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgaWYocmV2ZXJzZU11bHRpcGxpZXIgPCAwKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU11bHRpcGxpZXIgPSAtMTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXZlcnNlJyk7DQogICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhFbmVyZ2llczsNCiAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAvL0NhbGwgc2NhbGluZyBtZXRob2QNCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgNTsgaSsrKXsgIA0KICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlQ2FudmFzKCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIG5ld1BhdGggPSBmYWxzZTsNCiAgICAgICAgICAgICAgICB0aGlzLnBhdGhFbmVyZ2llcygpOw0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICB0aGlzLnNjYWxlQ2FudmFzID0gZnVuY3Rpb24oKSB7DQogICAgICAgICAgICAgICAgLy8gU2NhbGluZw0KICAgICAgICAgICAgICAgIGxldCBtYXhYID0gdGhpcy5wYXRoQ29vcmRzWzBdWzBdOw0KICAgICAgICAgICAgICAgIGxldCBtYXhZID0gdGhpcy5wYXRoQ29vcmRzWzBdWzFdOw0KICAgICAgICAgICAgICAgIGxldCBtaW5YID0gdGhpcy5wYXRoQ29vcmRzWzBdWzBdOw0KICAgICAgICAgICAgICAgIGxldCBtaW5ZID0gdGhpcy5wYXRoQ29vcmRzWzBdWzFdOw0KDQogICAgICAgICAgICAgICAgaWYodGhpcy5uZXdDb29yZHMubGVuZ3RoID4gMCl7DQogICAgICAgICAgICAgICAgICAgIG1heFggPSB0aGlzLm5ld0Nvb3Jkc1swXVswXTsNCiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHRoaXMubmV3Q29vcmRzWzBdWzFdOw0KICAgICAgICAgICAgICAgICAgICBtaW5YID0gdGhpcy5uZXdDb29yZHNbMF1bMF07DQogICAgICAgICAgICAgICAgICAgIG1pblkgPSB0aGlzLm5ld0Nvb3Jkc1swXVsxXTsNCg0KICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV3Q29vcmRzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLm5ld0Nvb3Jkc1tpXQ0KDQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRbMF0gPiBtYXhYKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4WCA9IGNvb3JkWzBdOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29vcmRbMF0gPCBtaW5YKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IGNvb3JkWzBdOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRbMV0gPiBtYXhZKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4WSA9IGNvb3JkWzFdOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29vcmRbMV0gPCBtaW5ZKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IGNvb3JkWzFdOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfSBlbHNlew0KICAgICAgICAgICAgICAgICAgICBtYXhYID0gdGhpcy5wYXRoQ29vcmRzWzBdWzBdOw0KICAgICAgICAgICAgICAgICAgICBtYXhZID0gdGhpcy5wYXRoQ29vcmRzWzBdWzFdOw0KICAgICAgICAgICAgICAgICAgICBtaW5YID0gdGhpcy5wYXRoQ29vcmRzWzBdWzBdOw0KICAgICAgICAgICAgICAgICAgICBtaW5ZID0gdGhpcy5wYXRoQ29vcmRzWzBdWzFdOw0KDQogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoQ29vcmRzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSB0aGlzLnBhdGhDb29yZHNbaV0NCg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkWzBdID4gbWF4WCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSBjb29yZFswXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvb3JkWzBdIDwgbWluWCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSBjb29yZFswXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkWzFdID4gbWF4WSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBjb29yZFsxXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvb3JkWzFdIDwgbWluWSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBjb29yZFsxXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgIGlmKG1heFggPCBjYW52YXMud2lkdGgqKDEvdGhpcy5zY2FsZSkvNCAmJiBtYXhZIDwgY2FudmFzLmhlaWdodCooMS90aGlzLnNjYWxlKS80ICYmIG1pblggPiAtY2FudmFzLndpZHRoKigxL3RoaXMuc2NhbGUpLzQgJiYgbWluWSA+IC1jYW52YXMuaGVpZ2h0KigxL3RoaXMuc2NhbGUpLzQpew0KICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZG93bnNpemUnLCBtYXhYLCBtaW5YLCBjYW52YXMud2lkdGgqKDEvdGhpcy5zY2FsZSkvNCwgbWF4WSwgbWluWSwgY2FudmFzLmhlaWdodCooMS90aGlzLnNjYWxlKS80KTsNCiAgICAgICAgICAgICAgICAgICAgYy5zY2FsZSgoMS90aGlzLnNjYWxlKSwgKDEvdGhpcy5zY2FsZSkpOw0KICAgICAgICAgICAgICAgICAgICAvLyBjLnRyYW5zbGF0ZShjYW52YXMud2lkdGgvNCwgY2FudmFzLmhlaWdodC80KTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuc2NhbGUqMjsNCiAgICAgICAgICAgICAgICAgICAgYy5zY2FsZSh0aGlzLnNjYWxlLCB0aGlzLnNjYWxlKTsNCiAgICAgICAgICAgICAgICB9ZWxzZSBpZihtYXhYID4gY2FudmFzLndpZHRoKigxL3RoaXMuc2NhbGUpLzIgfHwgbWF4WSA+IGNhbnZhcy5oZWlnaHQqKDEvdGhpcy5zY2FsZSkvMiB8fCBtaW5YIDwgLWNhbnZhcy53aWR0aCooMS90aGlzLnNjYWxlKS8yIHx8IG1pblkgPCAtY2FudmFzLmhlaWdodCooMS90aGlzLnNjYWxlKS8yKXsNCiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Vwc2l6ZScsIG1heFgsIG1pblgsIGNhbnZhcy53aWR0aCooMS90aGlzLnNjYWxlKS80LCBtYXhZLCBtaW5ZLCBjYW52YXMuaGVpZ2h0KigxL3RoaXMuc2NhbGUpLzQpOw0KICAgICAgICAgICAgICAgICAgICBjLnNjYWxlKCgxL3RoaXMuc2NhbGUpLCAoMS90aGlzLnNjYWxlKSk7DQogICAgICAgICAgICAgICAgICAgIC8vIGMudHJhbnNsYXRlKGNhbnZhcy53aWR0aC80LCBjYW52YXMuaGVpZ2h0LzQpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5zY2FsZS8yOw0KICAgICAgICAgICAgICAgICAgICBjLnNjYWxlKHRoaXMuc2NhbGUsIHRoaXMuc2NhbGUpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24oKSB7DQogICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBkZWZhdWx0UmFkaXVzKigxL3RoaXMuc2NhbGUpOw0KICAgICAgICAgICAgICAgIGxldCBhcnJvd09mZnNldCA9IHRoaXMucmFkaXVzKjM7DQoNCiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgICAgIGMubW92ZVRvKHRoaXMucGF0aENvb3Jkc1swXVswXSwgdGhpcy5wYXRoQ29vcmRzWzBdWzFdKTsNCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5wYXRoQ29vcmRzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8odGhpcy5wYXRoQ29vcmRzW2ldWzBdLCB0aGlzLnBhdGhDb29yZHNbaV1bMV0pOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBpZih0aGlzLmNsb3NlZFBhdGgpew0KICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyh0aGlzLnBhdGhDb29yZHNbMF1bMF0sIHRoaXMucGF0aENvb3Jkc1swXVsxXSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGMubGluZVdpZHRoID0gMiooMS90aGlzLnNjYWxlKTsNCiAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gImJsYWNrIjsNCiAgICAgICAgICAgICAgICBjLnN0cm9rZSgpOw0KDQogICAgICAgICAgICAgICAgaWYodGhpcy52ZWxvY2l0eVNlbGVjdCAmJiB0aGlzLm5ld0Nvb3Jkcy5sZW5ndGggPiAwKXsNCiAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8odGhpcy5uZXdDb29yZHNbMF1bMF0sIHRoaXMubmV3Q29vcmRzWzBdWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHRoaXMubmV3Q29vcmRzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHRoaXMubmV3Q29vcmRzW2ldWzBdLCB0aGlzLm5ld0Nvb3Jkc1tpXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jbG9zZWRQYXRoKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHRoaXMubmV3Q29vcmRzWzBdWzBdLCB0aGlzLm5ld0Nvb3Jkc1swXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSAyKigxL3RoaXMuc2NhbGUpOw0KICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gImJsdWUiOw0KICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZSgpOw0KICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgYy5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCAyKk1hdGguUEkpOw0KICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYigwLDAsMjU1KSc7DQogICAgICAgICAgICAgICAgYy5maWxsKCk7DQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgaWYodGhpcy52ZWxvY2l0eVNlbGVjdCl7DQogICAgICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgICAgIGMuYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cyoxLjUsIDAsIDIqTWF0aC5QSSk7DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYigwLDI1NSwwKSc7DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbCgpOw0KDQogICAgICAgICAgICAgICAgICAgIHRoaXMudGFuQW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMucGF0aENvb3Jkc1t0aGlzLnBhdGhJbmRleCsxXVsxXS0gdGhpcy5wYXRoQ29vcmRzW3RoaXMucGF0aEluZGV4LTFdWzFdLCB0aGlzLnBhdGhDb29yZHNbdGhpcy5wYXRoSW5kZXgrMV1bMF0tIHRoaXMucGF0aENvb3Jkc1t0aGlzLnBhdGhJbmRleC0xXVswXSk7DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJvd0NlbnRyZXMgPSBbXTsNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDQ7IGkrKyl7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFycm93Q2VudHJlcy5wdXNoKFt0aGlzLnggKyB0aGlzLnJhZGl1cyo0Kk1hdGguY29zKHRoaXMudGFuQW5nbGUgKyBpKk1hdGguUEkvMiksIHRoaXMueSArIHRoaXMucmFkaXVzKjQqTWF0aC5zaW4odGhpcy50YW5BbmdsZSArIGkqTWF0aC5QSS8yKV0pOw0KICAgICAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy50YW5Qb2ludHMxID0gcm90YXRlU2hhcGUodGhpcy50YW5BbmdsZSwgW3RoaXMueCwgdGhpcy55XSwgW1thcnJvd09mZnNldCwgdGhpcy5yYWRpdXNdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgdGhpcy5yYWRpdXNdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgdGhpcy5yYWRpdXMqMl0sIFt0aGlzLnJhZGl1cyozK2Fycm93T2Zmc2V0LCAwXSwNCiAgICAgICAgICAgICAgICAgICAgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIC10aGlzLnJhZGl1cyoyXSwgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIC10aGlzLnJhZGl1c10sIFthcnJvd09mZnNldCwgLXRoaXMucmFkaXVzXV0pOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnRhblBvaW50czIgPSByb3RhdGVTaGFwZSh0aGlzLnRhbkFuZ2xlICsgTWF0aC5QSSwgW3RoaXMueCwgdGhpcy55XSwgW1thcnJvd09mZnNldCwgdGhpcy5yYWRpdXNdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgdGhpcy5yYWRpdXNdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgdGhpcy5yYWRpdXMqMl0sIFt0aGlzLnJhZGl1cyozK2Fycm93T2Zmc2V0LCAwXSwNCiAgICAgICAgICAgICAgICAgICAgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIC10aGlzLnJhZGl1cyoyXSwgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIC10aGlzLnJhZGl1c10sIFthcnJvd09mZnNldCwgLXRoaXMucmFkaXVzXV0pOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdFBvaW50czEgPSByb3RhdGVTaGFwZSh0aGlzLnRhbkFuZ2xlICsgTWF0aC5QSS8yLCBbdGhpcy54LCB0aGlzLnldLCBbW2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1cyoyXSwgW3RoaXMucmFkaXVzKjMrYXJyb3dPZmZzZXQsIDBdLA0KICAgICAgICAgICAgICAgICAgICBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzKjJdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzXSwgW2Fycm93T2Zmc2V0LCAtdGhpcy5yYWRpdXNdXSk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMucm90UG9pbnRzMiA9IHJvdGF0ZVNoYXBlKHRoaXMudGFuQW5nbGUgKyAzKk1hdGguUEkvMiwgW3RoaXMueCwgdGhpcy55XSwgW1thcnJvd09mZnNldCwgdGhpcy5yYWRpdXNdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgdGhpcy5yYWRpdXNdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgdGhpcy5yYWRpdXMqMl0sIFt0aGlzLnJhZGl1cyozK2Fycm93T2Zmc2V0LCAwXSwNCiAgICAgICAgICAgICAgICAgICAgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIC10aGlzLnJhZGl1cyoyXSwgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIC10aGlzLnJhZGl1c10sIFthcnJvd09mZnNldCwgLXRoaXMucmFkaXVzXV0pOw0KDQogICAgICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHRoaXMudGFuUG9pbnRzMVswXVswXSwgdGhpcy50YW5Qb2ludHMxWzBdWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHRoaXMudGFuUG9pbnRzMS5sZW5ndGg7IGkrKyl7DQogICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyh0aGlzLnRhblBvaW50czFbaV1bMF0sIHRoaXMudGFuUG9pbnRzMVtpXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAnYmx1ZSc7DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbCgpOw0KDQogICAgICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHRoaXMudGFuUG9pbnRzMlswXVswXSwgdGhpcy50YW5Qb2ludHMyWzBdWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHRoaXMudGFuUG9pbnRzMi5sZW5ndGg7IGkrKyl7DQogICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyh0aGlzLnRhblBvaW50czJbaV1bMF0sIHRoaXMudGFuUG9pbnRzMltpXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAnYmx1ZSc7DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbCgpOw0KDQoNCiAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8odGhpcy5yb3RQb2ludHMxWzBdWzBdLCB0aGlzLnJvdFBvaW50czFbMF1bMV0pOw0KICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5yb3RQb2ludHMxLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHRoaXMucm90UG9pbnRzMVtpXVswXSwgdGhpcy5yb3RQb2ludHMxW2ldWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdwdXJwbGUnOw0KICAgICAgICAgICAgICAgICAgICBjLmZpbGwoKTsNCg0KICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyh0aGlzLnJvdFBvaW50czJbMF1bMF0sIHRoaXMucm90UG9pbnRzMlswXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLnJvdFBvaW50czIubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8odGhpcy5yb3RQb2ludHMyW2ldWzBdLCB0aGlzLnJvdFBvaW50czJbaV1bMV0pOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3B1cnBsZSc7DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbCgpOw0KICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgIGlmKHZtLnRvdWNoU2VsZWN0KXsNCiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGRpc3BYID0gY3VycmVudFRvdWNoWCAtIGluaXRpYWxUb3VjaFg7DQogICAgICAgICAgICAgICAgICAgIC8vIGxldCBkaXNwWSA9IGN1cnJlbnRUb3VjaFkgLSBpbml0aWFsVG91Y2hZOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLm1hZyA9IE1hdGgucG93KE1hdGgucG93KGN1cnJlbnRUb3VjaFgtIHRoaXMueCwgMikgKyBNYXRoLnBvdyhjdXJyZW50VG91Y2hZLXRoaXMueSwgMiksIDAuNSk7DQogICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubWFnID4gdGhpcy5yYWRpdXMqMjApew0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWcgPSB0aGlzLnJhZGl1cyoyMDsNCiAgICAgICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dBbmdsZSA9IE1hdGguYXRhbjIoY3VycmVudFRvdWNoWSAtIHRoaXMueSwgY3VycmVudFRvdWNoWCAtIHRoaXMueCk7DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJvd1BvaW50cyA9IHJvdGF0ZVNoYXBlKHRoaXMuYXJyb3dBbmdsZSwgW3RoaXMueCwgdGhpcy55XSwgW1swLDBdLCBbdGhpcy5tYWcsIHRoaXMucmFkaXVzKjJdLCBbdGhpcy5tYWcsIHRoaXMucmFkaXVzKjZdLCBbdGhpcy5tYWcgKyB0aGlzLnJhZGl1cyo2LCAwXSxbdGhpcy5tYWcsIC10aGlzLnJhZGl1cyo2XSAsW3RoaXMubWFnLCAtdGhpcy5yYWRpdXMqMl1dKTsNCg0KICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyh0aGlzLngsIHRoaXMueSk7DQogICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmFycm93UG9pbnRzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHRoaXMuYXJyb3dQb2ludHNbaV1bMF0sIHRoaXMuYXJyb3dQb2ludHNbaV1bMV0pOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMCwgMjU1LCAwLCAwLjcpJzsNCiAgICAgICAgICAgICAgICAgICAgYy5maWxsKCk7DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJvd0NvbmZpcm1lZCA9IHRydWU7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkgew0KDQogICAgICAgICAgICAgICAgdGhpcy50aW1lU2luY2VDbGljayArPSAxOyANCiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoKTsNCg0KICAgICAgICAgICAgICAgIGlmKHRoaXMucGF0aEluZGV4ID49IHRoaXMucGF0aENvb3Jkcy5sZW5ndGgpew0KICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhJbmRleD0xOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICBpZighdGhpcy52ZWxvY2l0eVNlbGVjdCAmJiAhdm0udG91Y2hTZWxlY3Qpew0KICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLnBhdGhDb29yZHNbdGhpcy5wYXRoSW5kZXhdWzBdOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnBhdGhDb29yZHNbdGhpcy5wYXRoSW5kZXhdWzFdOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmR4ID0gdGhpcy5wYXRoVmVsc1t0aGlzLnBhdGhJbmRleF1bMF07DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZHkgPSB0aGlzLnBhdGhWZWxzW3RoaXMucGF0aEluZGV4XVsxXTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoSW5kZXggKz0gdm0uYW5pbWF0aW9uU3BlZWQ7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIGlmKHZtLnZlbG9jaXR5U2VsZWN0ICYmIE1hdGgucG93KChNYXRoLnBvdygobW91c2VYLXRoaXMueCksMikgKyBNYXRoLnBvdygobW91c2VZLXRoaXMueSksMikpLDEvMikgPCB0aGlzLnJhZGl1cyoxLjUgJiYgdGhpcy50aW1lU2luY2VDbGljayA+IDIwKXsNCiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy52ZWxvY2l0eVNlbGVjdCAmJiB0aGlzLm5ld0Nvb3Jkcy5sZW5ndGggPiAwKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aENvb3JkcyA9IHRoaXMubmV3Q29vcmRzOw0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoVmVscyA9IHRoaXMubmV3VmVsczsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Q29vcmRzID0gW107DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZlbHMgPSBbXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aEluZGV4ID0gMTsgDQogICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVTaW5jZUNsaWNrID0gMDsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVNlbGVjdCA9ICF0aGlzLnZlbG9jaXR5U2VsZWN0Ow0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICBpZih0aGlzLnZlbG9jaXR5U2VsZWN0KXsNCiAgICAgICAgICAgICAgICAgICAgLy8gaWYoYmFsbEFycmF5Lmxlbmd0aCA9IDEpew0KICAgICAgICAgICAgICAgICAgICAvLyAgICAgYmFsbEFycmF5LnB1c2gobmV3IEJhbGwoY2FudmFzLndpZHRoLzMsIGNhbnZhcy5oZWlnaHQvMywgMTAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKSk7DQogICAgICAgICAgICAgICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKGJhbGxBcnJheSk7DQogICAgICAgICAgICAgICAgICAgIC8vIH0NCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYXJyb3dDZW50cmVzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZtLnZlbG9jaXR5U2VsZWN0ICYmIE1hdGgucG93KChNYXRoLnBvdygobW91c2VYLXRoaXMuYXJyb3dDZW50cmVzW2ldWzBdKSwyKSArIE1hdGgucG93KChtb3VzZVktdGhpcy5hcnJvd0NlbnRyZXNbaV1bMV0pLDIpKSwxLzIpIDwgdGhpcy5yYWRpdXMqMiAmJiB0aGlzLnRpbWVTaW5jZUNsaWNrID4gMjApew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGltZVNpbmNlQ2xpY2sgPSAwOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkgPT0gMCl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0YW5nZW50aWFsIG91dCcpOyANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeCArPSB0aGlzLmJ1dHRvblN0ZXAgKiBNYXRoLmNvcyh0aGlzLnRhbkFuZ2xlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeSArPSB0aGlzLmJ1dHRvblN0ZXAgKiBNYXRoLnNpbih0aGlzLnRhbkFuZ2xlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaSA9PSAxKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JhZGlhbCBpbicpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R4ICs9IHRoaXMuYnV0dG9uU3RlcCAqIE1hdGguc2luKHRoaXMudGFuQW5nbGUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R5ICs9IHRoaXMuYnV0dG9uU3RlcCAqIE1hdGguY29zKHRoaXMudGFuQW5nbGUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpID09IDIpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGFuZ2VudGlhbCBpbicpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R4ICs9IC10aGlzLmJ1dHRvblN0ZXAgKiBNYXRoLmNvcyh0aGlzLnRhbkFuZ2xlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeSArPSAtdGhpcy5idXR0b25TdGVwICogTWF0aC5zaW4odGhpcy50YW5BbmdsZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkgPT0gMyl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyYWRpYWwgb3V0Jyk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHggKz0gLXRoaXMuYnV0dG9uU3RlcCAqIE1hdGguc2luKHRoaXMudGFuQW5nbGUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R5ICs9IC10aGlzLmJ1dHRvblN0ZXAgKiBNYXRoLmNvcyh0aGlzLnRhbkFuZ2xlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Fycm93IFByZXNzJyk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoKHRoaXMubmV3ZHgsIHRoaXMubmV3ZHkpOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeCA9IHRoaXMuZHg7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHkgPSB0aGlzLmR5Ow0KICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgIC8vQ2hhbmdlIHZlbG9jaXR5IGFuZCBkcmF3IG5ldyBwYXRoIHdoZW4gdG91Y2ggcmVsZWFzZWQNCiAgICAgICAgICAgICAgICBpZighdm0udG91Y2hTZWxlY3QgJiYgdGhpcy5hcnJvd0NvbmZpcm1lZCl7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHggPSB0aGlzLmR4ICsgKE1hdGguY29zKHRoaXMuYXJyb3dBbmdsZSkpICogKDAuMDAwNSp0aGlzLm1hZy90aGlzLnJhZGl1cyoyMCk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHkgPSB0aGlzLmR5ICsgKE1hdGguc2luKHRoaXMuYXJyb3dBbmdsZSkpICogKDAuMDAwNSp0aGlzLm1hZy90aGlzLnJhZGl1cyoyMCk7DQogICAgICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgICAgICBuZXdQYXRoID0gdHJ1ZTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdDb29yZHMgPSBbXTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdWZWxzID0gW107DQogICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCh0aGlzLm5ld2R4LCB0aGlzLm5ld2R5KTsNCg0KICAgICAgICAgICAgICAgICAgICBpZih0aGlzLm5ld0Nvb3Jkcy5sZW5ndGggPiAwKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aENvb3JkcyA9IHRoaXMubmV3Q29vcmRzOw0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoVmVscyA9IHRoaXMubmV3VmVsczsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY2xvc2VkUGF0aCl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoSW5kZXggPSAxOyANCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhJbmRleCA9IE1hdGgucm91bmQodGhpcy5wYXRoQ29vcmRzLmxlbmd0aC8yKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dDb25maXJtZWQgPSBmYWxzZTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgDQogICAgICAgIC8vbGV0IG1heFJhZGl1cyA9IDMwOw0KICAgICAgICAvL2xldCBtb3VzZVJhZGl1cyA9IDU1Ow0KICAgICAgICBsZXQgYmFsbEFycmF5ID0gW107DQoNCiAgICAgICAgLy8gW1t4LHksIG1hc3NdXQ0KICAgICAgICAvL2xldCBtYXNzQ2VudHJlcyA9IFtbY2FudmFzLndpZHRoLzMsIGNhbnZhcy5oZWlnaHQvM10sIFsyKmNhbnZhcy53aWR0aC8zLCBjYW52YXMuaGVpZ2h0LzNdLCBbY2FudmFzLndpZHRoLzIsIDIqY2FudmFzLmhlaWdodC8zXV07DQogICAgICAgIGxldCBtYXNzQ2VudHJlcyA9IFtbMCwgMCAsIDEwMF1dOw0KICAgICAgICBsZXQgaW5pdGlhbFZlbCA9IDE7DQoNCiAgICAgICAgYmFsbEFycmF5LnB1c2gobmV3IEJhbGwoY2FudmFzLndpZHRoLzMsIGNhbnZhcy5oZWlnaHQvMywgNSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpKTsNCiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGJhbGxBcnJheS5sZW5ndGg7IGkrKyl7DQogICAgICAgICAgICBiYWxsQXJyYXlbaV0ucGF0aCgpOw0KICAgICAgICB9DQoNCiAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHsNCiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTsNCg0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYWxsQXJyYXkubGVuZ3RoOyBpKyspeyAgICANCiAgICAgICAgICAgICAgICBjLmNsZWFyUmVjdCgtY2FudmFzLndpZHRoKigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMiwgLWNhbnZhcy5oZWlnaHQqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yLCBjYW52YXMud2lkdGgqKDEvYmFsbEFycmF5W2ldLnNjYWxlKSwgY2FudmFzLmhlaWdodCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpKTsNCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAvL2JvdW5kaW5nIGJveA0KICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgYy5tb3ZlVG8oLWNhbnZhcy53aWR0aCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpLzIsIC1jYW52YXMuaGVpZ2h0KigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMik7DQogICAgICAgICAgICAgICAgYy5saW5lVG8oY2FudmFzLndpZHRoKigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMiwgLWNhbnZhcy5oZWlnaHQqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yKTsNCiAgICAgICAgICAgICAgICBjLmxpbmVUbyhjYW52YXMud2lkdGgqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yLCBjYW52YXMuaGVpZ2h0KigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMik7DQogICAgICAgICAgICAgICAgYy5saW5lVG8oLWNhbnZhcy53aWR0aCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpLzIsIGNhbnZhcy5oZWlnaHQqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yKTsNCiAgICAgICAgICAgICAgICBjLmxpbmVUbygtY2FudmFzLndpZHRoKigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMiwgLWNhbnZhcy5oZWlnaHQqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yKTsNCiAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDE7DQogICAgICAgICAgICAgICAgYy5zdHJva2UoKTsNCiAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgbW91c2VYID0gKHZtLm1vdXNlLnggLSByZWN0LmxlZnQgLSBjYW52YXMud2lkdGgvMikqKDEvYmFsbEFycmF5WzBdLnNjYWxlKTsNCiAgICAgICAgICAgIG1vdXNlWSA9ICh2bS5tb3VzZS55IC0gcmVjdC50b3AgLSBjYW52YXMuaGVpZ2h0LzIpKigxL2JhbGxBcnJheVswXS5zY2FsZSk7DQogICAgICAgICAgICBjdXJyZW50VG91Y2hYID0gKHZtLmN1cnJlbnRUb3VjaFBvcy54IC0gcmVjdC5sZWZ0IC0gY2FudmFzLndpZHRoLzIpKigxL2JhbGxBcnJheVswXS5zY2FsZSk7DQogICAgICAgICAgICBjdXJyZW50VG91Y2hZID0gKHZtLmN1cnJlbnRUb3VjaFBvcy55IC0gcmVjdC50b3AgLSBjYW52YXMuaGVpZ2h0LzIpKigxL2JhbGxBcnJheVswXS5zY2FsZSk7DQogICAgICAgICAgICAvLyBpbml0aWFsVG91Y2hYID0gKHZtLmluaXRpYWxUb3VjaFBvcy54IC0gcmVjdC5sZWZ0IC0gY2FudmFzLndpZHRoLzIpKigxL2JhbGxBcnJheVswXS5zY2FsZSk7DQogICAgICAgICAgICAvLyBpbml0aWFsVG91Y2hZID0gKHZtLmluaXRpYWxUb3VjaFBvcy55IC0gcmVjdC50b3AgLSBjYW52YXMuaGVpZ2h0LzIpKigxL2JhbGxBcnJheVswXS5zY2FsZSk7DQoNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsbEFycmF5Lmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICBiYWxsQXJyYXlbaV0udXBkYXRlKCk7DQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDxtYXNzQ2VudHJlcy5sZW5ndGg7IGkrKyl7DQogICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgICAgICBjLmFyYyhtYXNzQ2VudHJlc1tpXVswXSwgbWFzc0NlbnRyZXNbaV1bMV0sIHZtLnN1blJhZGl1cywgMCwgTWF0aC5QSSAqIDIpOyANCiAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdPcmFuZ2UnOw0KICAgICAgICAgICAgICAgIGMuZmlsbCgpOw0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAvLyBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgLy8gYy5hcmMobW91c2VYLCBtb3VzZVksIDIwLCAwLCBNYXRoLlBJICogMik7DQogICAgICAgICAgICAvLyBjLmZpbGxTdHlsZSA9ICJibGFjayI7DQogICAgICAgICAgICAvLyBjLmZpbGwoKTsNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgLy8gYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgIC8vIGMuYXJjKDIzMTYsIDY2OSwgNTAwLCAwLCBNYXRoLlBJICogMik7IA0KICAgICAgICAgICAgLy8gYy5maWxsU3R5bGUgPSAnUmVkJzsNCiAgICAgICAgICAgIC8vIGMuZmlsbCgpOw0KICAgICAgICAgICAgDQogICAgICAgIH0NCg0KICAgICAgICBhbmltYXRlKCk7DQoNCiAgICB9DQoNCn0NCg=="},{"version":3,"sources":["Orbits.vue"],"names":[],"mappings":";;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA","file":"Orbits.vue","sourceRoot":"src/components","sourcesContent":["<template>\r\n    <div id=\"parent\" style=\"height:90vh;\" @mousemove=\"mouseOver\" @mouseleave=\"mouseLeave\" @mousedown=\"activateSelect\" @mouseup=\"cancelSelect\" @touchstart=\"touchOn\" @touchend=\"touchOff\" @touchmove=\"touchChange\">\r\n         <canvas id=\"front-animation\" style=\"width:100%; height:100%\" ></canvas>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name: 'iv-orbits',\r\n    props: {\r\n        mouse: {\r\n            default: {\r\n                x: undefined,\r\n                y: undefined\r\n            }\r\n        },\r\n        animationSpeed: {\r\n            default: 1\r\n        },\r\n        velocitySelect: {\r\n            default: false\r\n        },\r\n        sunRadius: {\r\n            default: 20\r\n        },\r\n        touchSelect: {\r\n            default: false\r\n        },\r\n        initialTouchPos:{\r\n            default: {\r\n                x: undefined,\r\n                y: undefined\r\n            }\r\n        },\r\n        currentTouchPos:{\r\n            default: {\r\n                x: undefined,\r\n                y: undefined\r\n            }\r\n        }\r\n    },\r\n    methods: {\r\n        touchOn(event){\r\n            this.initialTouchPos.x = event.touches[0].pageX;\r\n            this.initialTouchPos.y = event.touches[0].pageY;\r\n            console.log('touchOn');\r\n        },\r\n        touchOff(){\r\n            this.touchSelect = false;\r\n            this.currentTouchPos.x = undefined;\r\n            this.currentTouchPos.y = undefined;\r\n            this.initialTouchPos.x = undefined;\r\n            this.initialTouchPos.y = undefined;\r\n            console.log('touchOff');\r\n        },\r\n        touchChange(event){\r\n            this.touchSelect = true;\r\n            this.currentTouchPos.x = event.touches[0].pageX;\r\n            this.currentTouchPos.y = event.touches[0].pageY;\r\n        },\r\n        mouseOver(event){\r\n            this.mouse.x = event.x;\r\n            this.mouse.y = event.y;\r\n        },\r\n        mouseLeave(){\r\n            this.mouse.x = undefined;\r\n            this.mouse.y = undefined;\r\n        },\r\n        activateSelect(){\r\n            this.velocitySelect = true;\r\n        },\r\n        cancelSelect(){\r\n            this.velocitySelect = false;\r\n        },\r\n\r\n    },\r\n    mounted(){\r\n        let canvas = document.querySelector('canvas');\r\n        let parent = document.getElementById('parent');\r\n        canvas.width = parent.offsetWidth;\r\n        canvas.height = parent.offsetHeight;\r\n        let rect = parent.getBoundingClientRect();\r\n\r\n        let vm = this;\r\n        let mouseX = this.mouse.x - rect.left;\r\n        let mouseY = this.mouse.y - rect.top;\r\n        let currentTouchX = this.currentTouchPos.x - rect.left;\r\n        let currentTouchY = this.currentTouchPos.y - rect.top;\r\n        // let initialTouchX = this.initialTouchPos.x - rect.left;\r\n        // let initialTouchY = this.initialTouchPos.y - rect.top;\r\n\r\n\r\n        let c = canvas.getContext('2d');\r\n        //centre about x=0, y=0\r\n        c.translate(canvas.width/2, canvas.height/2);\r\n\r\n\r\n        function rotateShape(angle, centre, points){\r\n            //console.log(angle, centre, points);\r\n            for(let i = 0; i < points.length; i++){\r\n                points[i] = [points[i][0]*Math.cos(angle) - points[i][1]*Math.sin(angle), points[i][0]*Math.sin(angle) + points[i][1]*Math.cos(angle)];\r\n                points[i][0] = centre[0] + points[i][0];\r\n                points[i][1] = centre[1] + points[i][1];\r\n            }\r\n            return points;\r\n        }\r\n\r\n        \r\n        function Ball(x, y, defaultRadius, dx, dy) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.radius = defaultRadius;\r\n            this.pathIndex = 0;\r\n            this.velocitySelect = false;\r\n            this.touchInterface = false;\r\n            this.timeSinceClick = 10;\r\n            this.buttonStep = 0.1;\r\n            this.arrowConfirmed = false;\r\n            let newPath = false;\r\n\r\n            if(dx == undefined || dy == undefined){\r\n                            //make all orbit in circular orbits in same direction initially \r\n                this.dx = 0;\r\n                this.dy = 0;\r\n\r\n                for(let i = 0; i < massCentres.length; i++){  \r\n                    this.dist = Math.pow(Math.pow(this.x-massCentres[i][0] , 2) + Math.pow(this.y-massCentres[i][1], 2), 0.5);\r\n                    this.dy += -initialVel*massCentres[i][2]*Math.abs(Math.pow(this.dist , -2))*(massCentres[i][0]-this.x);\r\n                }\r\n                for(let i = 0; i < massCentres.length; i++){\r\n                    this.dist = Math.pow(Math.pow(this.x-massCentres[i][0] , 2) + Math.pow(this.y-massCentres[i][1], 2), 0.5);\r\n                    this.dx += initialVel*massCentres[i][2]*Math.abs(Math.pow(this.dist , -2))*(massCentres[i][1]-this.y);\r\n                }\r\n            } else {\r\n                this.dx = dx;\r\n                this.dy = dy;\r\n            }\r\n\r\n            this.pathEnergies = function(){\r\n                this.pathGravPot = [];\r\n                this.pathAngMom = [];\r\n                this.pathEffPot = [];\r\n                this.totE = 0;\r\n\r\n                for(let i = 0; i < this.pathCoords.length; i++){\r\n                    // Taking mass of orbiting object as 1\r\n                    this.dist = Math.pow(Math.pow(this.pathCoords[i][0]-massCentres[0][0] , 2) + Math.pow(this.pathCoords[i][1]-massCentres[0][1], 2), 0.5);\r\n                    this.pathGravPot.push(-initialVel*massCentres[0][2]/(this.dist*4*Math.PI));\r\n                    this.pathAngMom.push(Math.pow(Math.pow(this.pathVels[i][0],2) + Math.pow(this.pathVels[i][1],2),0.5) * this.dist /massCentres[0][2]);\r\n                    this.pathEffPot.push(this.pathGravPot[i] + this.pathAngMom[i]);\r\n                }\r\n\r\n                this.totE = 0.5*Math.pow(this.pathAngMom[0] ,2) + this.pathGravPot[0];\r\n                console.log('total energy = ',this.totE);\r\n                //this.totE = 0.5*(Math.pow(this.dx,2) + Math.pow(this.dy,2)) + massCentres[i][2]*Math.abs(this.dist, -1);\r\n                vm.$emit('energies', [this.pathAngMom, this.pathGravPot, this.pathEffPot,this.totE]);\r\n                console.log('emitted');\r\n                \r\n            }\r\n\r\n            this.path = function(dx, dy)  {\r\n                let currentPos = [this.x, this.y];\r\n                let currentVel = [this.dx, this.dy];\r\n                console.log(this.velocitySelect);\r\n                if(this.velocitySelect || newPath){\r\n                    if(isNaN(dx) || isNaN(dy)){\r\n                        currentVel = [this.x, this.y];\r\n                    } else {\r\n                        currentVel = [dx, dy];\r\n                    }\r\n                } else {      \r\n                    this.pathVels = [];\r\n                    this.pathCoords = [];\r\n                    this.scale = 1;\r\n                }\r\n                let iterations = 0;\r\n                this.newCoords = [];\r\n                this.newVels = [];\r\n                let stepSize = 1;\r\n                this.closedPath = true;\r\n                let reverseMultiplier = 1;\r\n                this.maxIterations = 20000;\r\n                console.log('path drawing');\r\n\r\n                while(Math.pow((Math.pow(this.x-currentPos[0], 2) + Math.pow(this.y-currentPos[1],2)),0.5) > 1 || iterations < 100){\r\n\r\n                    currentPos[0] += currentVel[0] * reverseMultiplier * stepSize;\r\n                    currentPos[1] += currentVel[1] * reverseMultiplier * stepSize;\r\n\r\n                    for(let i = 0; i < massCentres.length; i++){\r\n                        let dist = Math.pow(Math.pow(currentPos[0]-massCentres[i][0] , 2) + Math.pow(currentPos[1]-massCentres[i][1], 2), 0.5);\r\n\r\n                        currentVel[0] = currentVel[0] + reverseMultiplier * massCentres[i][2]*Math.abs(Math.pow(dist , -3))*(massCentres[i][0]-currentPos[0]);\r\n                        currentVel[1] = currentVel[1] + reverseMultiplier * massCentres[i][2]*Math.abs(Math.pow(dist , -3))*(massCentres[i][1]-currentPos[1]);\r\n                    }\r\n\r\n                    if (this.closedPath){\r\n                        if(this.velocitySelect || newPath){\r\n                            this.newCoords.push(currentPos.slice());\r\n                            this.newVels.push(currentVel.slice());\r\n                        } else{\r\n                            this.pathCoords.push(currentPos.slice());\r\n                            this.pathVels.push(currentVel.slice());\r\n                        }\r\n                    } else{\r\n                        if(this.velocitySelect || newPath){\r\n                            this.newCoords.unshift(currentPos.slice());\r\n                            this.newVels.unshift(currentVel.slice());\r\n                        } else{\r\n                            this.pathCoords.unshift(currentPos.slice());\r\n                            this.pathVels.unshift(currentVel.slice());\r\n                        }\r\n                    }\r\n\r\n                    iterations += 1;\r\n                    \r\n                    //Draw reverse path for open path\r\n                    if(iterations > this.maxIterations || Math.pow(Math.pow(currentPos[0],2) + Math.pow(currentPos[1],2),0.5) < vm.sunRadius){\r\n                        this.maxIterations = iterations;\r\n                        this.closedPath = false;\r\n                        if(this.velocitySelect || newPath){\r\n                            currentPos = [this.x, this.y];\r\n                            currentVel = [dx, dy];\r\n                        } else {\r\n                            currentPos = [this.x, this.y];\r\n                            currentVel = [this.dx, this.dy];\r\n                        }\r\n                        iterations = 0;\r\n                        \r\n                        if(reverseMultiplier < 0){\r\n                            break;\r\n                        }\r\n\r\n                        reverseMultiplier = -1;\r\n                        console.log('reverse');\r\n                    }\r\n\r\n                    this.pathEnergies;\r\n                }\r\n\r\n                //Call scaling method\r\n                for(let i = 0; i < 5; i++){  \r\n                    this.scaleCanvas();\r\n                }\r\n                \r\n                newPath = false;\r\n                this.pathEnergies();\r\n            }\r\n\r\n            this.scaleCanvas = function() {\r\n                // Scaling\r\n                let maxX = this.pathCoords[0][0];\r\n                let maxY = this.pathCoords[0][1];\r\n                let minX = this.pathCoords[0][0];\r\n                let minY = this.pathCoords[0][1];\r\n\r\n                if(this.newCoords.length > 0){\r\n                    maxX = this.newCoords[0][0];\r\n                    maxY = this.newCoords[0][1];\r\n                    minX = this.newCoords[0][0];\r\n                    minY = this.newCoords[0][1];\r\n\r\n                    for (let i = 0; i < this.newCoords.length; i++) {\r\n                        let coord = this.newCoords[i]\r\n\r\n                        if (coord[0] > maxX) {\r\n                            maxX = coord[0];\r\n                        }\r\n                        else if (coord[0] < minX) {\r\n                            minX = coord[0];\r\n                        }\r\n\r\n                        if (coord[1] > maxY) {\r\n                            maxY = coord[1];\r\n                        }\r\n                        else if (coord[1] < minY) {\r\n                            minY = coord[1];\r\n                        }\r\n                    }\r\n                } else{\r\n                    maxX = this.pathCoords[0][0];\r\n                    maxY = this.pathCoords[0][1];\r\n                    minX = this.pathCoords[0][0];\r\n                    minY = this.pathCoords[0][1];\r\n\r\n                    for (let i = 0; i < this.pathCoords.length; i++) {\r\n                        let coord = this.pathCoords[i]\r\n\r\n                        if (coord[0] > maxX) {\r\n                            maxX = coord[0];\r\n                        }\r\n                        else if (coord[0] < minX) {\r\n                            minX = coord[0];\r\n                        }\r\n\r\n                        if (coord[1] > maxY) {\r\n                            maxY = coord[1];\r\n                        }\r\n                        else if (coord[1] < minY) {\r\n                            minY = coord[1];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(maxX < canvas.width*(1/this.scale)/4 && maxY < canvas.height*(1/this.scale)/4 && minX > -canvas.width*(1/this.scale)/4 && minY > -canvas.height*(1/this.scale)/4){\r\n                    console.log('downsize', maxX, minX, canvas.width*(1/this.scale)/4, maxY, minY, canvas.height*(1/this.scale)/4);\r\n                    c.scale((1/this.scale), (1/this.scale));\r\n                    // c.translate(canvas.width/4, canvas.height/4);\r\n                    this.scale = this.scale*2;\r\n                    c.scale(this.scale, this.scale);\r\n                }else if(maxX > canvas.width*(1/this.scale)/2 || maxY > canvas.height*(1/this.scale)/2 || minX < -canvas.width*(1/this.scale)/2 || minY < -canvas.height*(1/this.scale)/2){\r\n                    console.log('upsize', maxX, minX, canvas.width*(1/this.scale)/4, maxY, minY, canvas.height*(1/this.scale)/4);\r\n                    c.scale((1/this.scale), (1/this.scale));\r\n                    // c.translate(canvas.width/4, canvas.height/4);\r\n                    this.scale = this.scale/2;\r\n                    c.scale(this.scale, this.scale);\r\n                }\r\n            }\r\n\r\n            this.draw = function() {\r\n                this.radius = defaultRadius*(1/this.scale);\r\n                let arrowOffset = this.radius*3;\r\n\r\n                c.beginPath();\r\n                c.moveTo(this.pathCoords[0][0], this.pathCoords[0][1]);\r\n                for(let i = 1; i < this.pathCoords.length; i++){\r\n                    c.lineTo(this.pathCoords[i][0], this.pathCoords[i][1]);\r\n                }\r\n                if(this.closedPath){\r\n                    c.lineTo(this.pathCoords[0][0], this.pathCoords[0][1]);\r\n                }\r\n                c.lineWidth = 2*(1/this.scale);\r\n                c.strokeStyle = \"black\";\r\n                c.stroke();\r\n\r\n                if(this.velocitySelect && this.newCoords.length > 0){\r\n                    c.beginPath();\r\n                    c.moveTo(this.newCoords[0][0], this.newCoords[0][1]);\r\n                    for(let i = 1; i < this.newCoords.length; i++){\r\n                        c.lineTo(this.newCoords[i][0], this.newCoords[i][1]);\r\n                    }\r\n                    if(this.closedPath){\r\n                        c.lineTo(this.newCoords[0][0], this.newCoords[0][1]);\r\n                    }\r\n                    c.lineWidth = 2*(1/this.scale);\r\n                    c.strokeStyle = \"blue\";\r\n                    c.stroke();\r\n                }\r\n\r\n                c.beginPath();\r\n                c.arc(this.x, this.y, this.radius, 0, 2*Math.PI);\r\n                c.fillStyle = 'rgb(0,0,255)';\r\n                c.fill();\r\n                \r\n                if(this.velocitySelect){\r\n                    c.beginPath();\r\n                    c.arc(this.x, this.y, this.radius*1.5, 0, 2*Math.PI);\r\n                    c.fillStyle = 'rgb(0,255,0)';\r\n                    c.fill();\r\n\r\n                    this.tanAngle = Math.atan2(this.pathCoords[this.pathIndex+1][1]- this.pathCoords[this.pathIndex-1][1], this.pathCoords[this.pathIndex+1][0]- this.pathCoords[this.pathIndex-1][0]);\r\n\r\n                    this.arrowCentres = [];\r\n                    for(let i = 0; i < 4; i++){\r\n                        this.arrowCentres.push([this.x + this.radius*4*Math.cos(this.tanAngle + i*Math.PI/2), this.y + this.radius*4*Math.sin(this.tanAngle + i*Math.PI/2)]);\r\n                    }\r\n\r\n                    this.tanPoints1 = rotateShape(this.tanAngle, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n                    this.tanPoints2 = rotateShape(this.tanAngle + Math.PI, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n                    this.rotPoints1 = rotateShape(this.tanAngle + Math.PI/2, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n                    this.rotPoints2 = rotateShape(this.tanAngle + 3*Math.PI/2, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.tanPoints1[0][0], this.tanPoints1[0][1]);\r\n                    for(let i = 1; i < this.tanPoints1.length; i++){\r\n                        c.lineTo(this.tanPoints1[i][0], this.tanPoints1[i][1]);\r\n                    }\r\n                    c.fillStyle = 'blue';\r\n                    c.fill();\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.tanPoints2[0][0], this.tanPoints2[0][1]);\r\n                    for(let i = 1; i < this.tanPoints2.length; i++){\r\n                        c.lineTo(this.tanPoints2[i][0], this.tanPoints2[i][1]);\r\n                    }\r\n                    c.fillStyle = 'blue';\r\n                    c.fill();\r\n\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.rotPoints1[0][0], this.rotPoints1[0][1]);\r\n                    for(let i = 1; i < this.rotPoints1.length; i++){\r\n                        c.lineTo(this.rotPoints1[i][0], this.rotPoints1[i][1]);\r\n                    }\r\n                    c.fillStyle = 'purple';\r\n                    c.fill();\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.rotPoints2[0][0], this.rotPoints2[0][1]);\r\n                    for(let i = 1; i < this.rotPoints2.length; i++){\r\n                        c.lineTo(this.rotPoints2[i][0], this.rotPoints2[i][1]);\r\n                    }\r\n                    c.fillStyle = 'purple';\r\n                    c.fill();\r\n                }\r\n\r\n                if(vm.touchSelect){\r\n                    // let dispX = currentTouchX - initialTouchX;\r\n                    // let dispY = currentTouchY - initialTouchY;\r\n                    this.mag = Math.pow(Math.pow(currentTouchX- this.x, 2) + Math.pow(currentTouchY-this.y, 2), 0.5);\r\n                    if(this.mag > this.radius*20){\r\n                        this.mag = this.radius*20;\r\n                    }\r\n\r\n                    this.arrowAngle = Math.atan2(currentTouchY - this.y, currentTouchX - this.x);\r\n\r\n                    this.arrowPoints = rotateShape(this.arrowAngle, [this.x, this.y], [[0,0], [this.mag, this.radius*2], [this.mag, this.radius*6], [this.mag + this.radius*6, 0],[this.mag, -this.radius*6] ,[this.mag, -this.radius*2]]);\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.x, this.y);\r\n                    for(let i = 0; i < this.arrowPoints.length; i++){\r\n                        c.lineTo(this.arrowPoints[i][0], this.arrowPoints[i][1]);\r\n                    }\r\n                    c.fillStyle = 'rgba(0, 255, 0, 0.7)';\r\n                    c.fill();\r\n\r\n                    this.arrowConfirmed = true;\r\n                }\r\n            }\r\n\r\n            this.update = function() {\r\n\r\n                this.timeSinceClick += 1; \r\n                this.draw();\r\n\r\n                if(this.pathIndex >= this.pathCoords.length){\r\n                    this.pathIndex=1;\r\n                }\r\n                \r\n                if(!this.velocitySelect && !vm.touchSelect){\r\n                    this.x = this.pathCoords[this.pathIndex][0];\r\n                    this.y = this.pathCoords[this.pathIndex][1];\r\n                    this.dx = this.pathVels[this.pathIndex][0];\r\n                    this.dy = this.pathVels[this.pathIndex][1];\r\n                    this.pathIndex += vm.animationSpeed;\r\n                }\r\n                \r\n                if(vm.velocitySelect && Math.pow((Math.pow((mouseX-this.x),2) + Math.pow((mouseY-this.y),2)),1/2) < this.radius*1.5 && this.timeSinceClick > 20){\r\n                    if(this.velocitySelect && this.newCoords.length > 0){\r\n                        this.pathCoords = this.newCoords;\r\n                        this.pathVels = this.newVels;\r\n                        this.newCoords = [];\r\n                        this.newVels = [];\r\n                        this.pathIndex = 1; \r\n                    }\r\n\r\n                    this.timeSinceClick = 0;\r\n                    this.velocitySelect = !this.velocitySelect;\r\n                }\r\n                \r\n                if(this.velocitySelect){\r\n                    // if(ballArray.length = 1){\r\n                    //     ballArray.push(new Ball(canvas.width/3, canvas.height/3, 10, undefined, undefined));\r\n                    //     //console.log(ballArray);\r\n                    // }\r\n                    for(let i = 0; i < this.arrowCentres.length; i++){\r\n                        if(vm.velocitySelect && Math.pow((Math.pow((mouseX-this.arrowCentres[i][0]),2) + Math.pow((mouseY-this.arrowCentres[i][1]),2)),1/2) < this.radius*2 && this.timeSinceClick > 20){\r\n                            this.timeSinceClick = 0;\r\n                            if(i == 0){\r\n                                console.log('tangential out'); \r\n                                this.newdx += this.buttonStep * Math.cos(this.tanAngle);\r\n                                this.newdy += this.buttonStep * Math.sin(this.tanAngle);\r\n                            }\r\n                            if(i == 1){\r\n                                console.log('radial in');\r\n                                this.newdx += this.buttonStep * Math.sin(this.tanAngle);\r\n                                this.newdy += this.buttonStep * Math.cos(this.tanAngle);\r\n                            }\r\n                            if(i == 2){\r\n                                console.log('tangential in');\r\n                                this.newdx += -this.buttonStep * Math.cos(this.tanAngle);\r\n                                this.newdy += -this.buttonStep * Math.sin(this.tanAngle);\r\n                            }\r\n                            if(i == 3){\r\n                                console.log('radial out');\r\n                                this.newdx += -this.buttonStep * Math.sin(this.tanAngle);\r\n                                this.newdy += -this.buttonStep * Math.cos(this.tanAngle);\r\n                            }\r\n                            console.log('arrow Press');\r\n                            this.path(this.newdx, this.newdy);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.newdx = this.dx;\r\n                    this.newdy = this.dy;\r\n                }\r\n\r\n                //Change velocity and draw new path when touch released\r\n                if(!vm.touchSelect && this.arrowConfirmed){\r\n                    this.newdx = this.dx + (Math.cos(this.arrowAngle)) * (0.0005*this.mag/this.radius*20);\r\n                    this.newdy = this.dy + (Math.sin(this.arrowAngle)) * (0.0005*this.mag/this.radius*20);\r\n                    \r\n                    newPath = true;\r\n                    this.newCoords = [];\r\n                    this.newVels = [];\r\n                    this.path(this.newdx, this.newdy);\r\n\r\n                    if(this.newCoords.length > 0){\r\n                        this.pathCoords = this.newCoords;\r\n                        this.pathVels = this.newVels;\r\n                        if(this.closedPath){\r\n                            this.pathIndex = 1; \r\n                        } else{\r\n                            this.pathIndex = Math.round(this.pathCoords.length/2);\r\n                        }\r\n                    }\r\n\r\n                    this.arrowConfirmed = false;\r\n                }\r\n            }\r\n        }\r\n        \r\n        //let maxRadius = 30;\r\n        //let mouseRadius = 55;\r\n        let ballArray = [];\r\n\r\n        // [[x,y, mass]]\r\n        //let massCentres = [[canvas.width/3, canvas.height/3], [2*canvas.width/3, canvas.height/3], [canvas.width/2, 2*canvas.height/3]];\r\n        let massCentres = [[0, 0 , 100]];\r\n        let initialVel = 1;\r\n\r\n        ballArray.push(new Ball(canvas.width/3, canvas.height/3, 5, undefined, undefined));\r\n        for(let i = 0; i < ballArray.length; i++){\r\n            ballArray[i].path();\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            for (let i = 0; i < ballArray.length; i++){    \r\n                c.clearRect(-canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2, canvas.width*(1/ballArray[i].scale), canvas.height*(1/ballArray[i].scale));\r\n                \r\n                //bounding box\r\n                c.beginPath();\r\n                c.moveTo(-canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2);\r\n                c.lineTo(canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2);\r\n                c.lineTo(canvas.width*(1/ballArray[i].scale)/2, canvas.height*(1/ballArray[i].scale)/2);\r\n                c.lineTo(-canvas.width*(1/ballArray[i].scale)/2, canvas.height*(1/ballArray[i].scale)/2);\r\n                c.lineTo(-canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2);\r\n                c.lineWidth = 1;\r\n                c.stroke();\r\n            }\r\n\r\n            mouseX = (vm.mouse.x - rect.left - canvas.width/2)*(1/ballArray[0].scale);\r\n            mouseY = (vm.mouse.y - rect.top - canvas.height/2)*(1/ballArray[0].scale);\r\n            currentTouchX = (vm.currentTouchPos.x - rect.left - canvas.width/2)*(1/ballArray[0].scale);\r\n            currentTouchY = (vm.currentTouchPos.y - rect.top - canvas.height/2)*(1/ballArray[0].scale);\r\n            // initialTouchX = (vm.initialTouchPos.x - rect.left - canvas.width/2)*(1/ballArray[0].scale);\r\n            // initialTouchY = (vm.initialTouchPos.y - rect.top - canvas.height/2)*(1/ballArray[0].scale);\r\n\r\n            for (let i = 0; i < ballArray.length; i++){\r\n                ballArray[i].update();\r\n            }\r\n\r\n            for (let i = 0; i <massCentres.length; i++){\r\n                c.beginPath();\r\n                c.arc(massCentres[i][0], massCentres[i][1], vm.sunRadius, 0, Math.PI * 2); \r\n                c.fillStyle = 'Orange';\r\n                c.fill();\r\n            }\r\n\r\n            // c.beginPath();\r\n            // c.arc(mouseX, mouseY, 20, 0, Math.PI * 2);\r\n            // c.fillStyle = \"black\";\r\n            // c.fill();\r\n            \r\n            // c.beginPath();\r\n            // c.arc(2316, 669, 500, 0, Math.PI * 2); \r\n            // c.fillStyle = 'Red';\r\n            // c.fill();\r\n            \r\n        }\r\n\r\n        animate();\r\n\r\n    }\r\n\r\n}\r\n</script>\r\n\r\n<style>\r\n#front-animation{\r\n    /* border: 1px solid black; */\r\n}\r\n</style>"]}]}