{"remainingRequest":"/home/robert/Desktop/Visualisations2020/Orbits/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/robert/Desktop/Visualisations2020/Orbits/src/components/Orbits.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/robert/Desktop/Visualisations2020/Orbits/src/components/Orbits.vue","mtime":1597404146291},{"path":"/home/robert/Desktop/Visualisations2020/Orbits/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/robert/Desktop/Visualisations2020/Orbits/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/robert/Desktop/Visualisations2020/Orbits/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/robert/Desktop/Visualisations2020/Orbits/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KDQpleHBvcnQgZGVmYXVsdCB7DQogICAgbmFtZTogJ2l2LW9yYml0cycsDQogICAgcHJvcHM6IHsNCiAgICAgICAgbW91c2U6IHsNCiAgICAgICAgICAgIGRlZmF1bHQ6IHsNCiAgICAgICAgICAgICAgICB4OiB1bmRlZmluZWQsDQogICAgICAgICAgICAgICAgeTogdW5kZWZpbmVkDQogICAgICAgICAgICB9DQogICAgICAgIH0sDQogICAgICAgIGFuaW1hdGlvblNwZWVkOiB7DQogICAgICAgICAgICBkZWZhdWx0OiAxDQogICAgICAgIH0sDQogICAgICAgIHZlbG9jaXR5U2VsZWN0OiB7DQogICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgICAgICB9LA0KICAgICAgICBzdW5SYWRpdXM6IHsNCiAgICAgICAgICAgIGRlZmF1bHQ6IDIwDQogICAgICAgIH0sDQogICAgICAgIHRvdWNoU2VsZWN0OiB7DQogICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgICAgICB9LA0KICAgICAgICBpbml0aWFsVG91Y2hQb3M6ew0KICAgICAgICAgICAgZGVmYXVsdDogew0KICAgICAgICAgICAgICAgIHg6IHVuZGVmaW5lZCwNCiAgICAgICAgICAgICAgICB5OiB1bmRlZmluZWQNCiAgICAgICAgICAgIH0NCiAgICAgICAgfSwNCiAgICAgICAgY3VycmVudFRvdWNoUG9zOnsNCiAgICAgICAgICAgIGRlZmF1bHQ6IHsNCiAgICAgICAgICAgICAgICB4OiB1bmRlZmluZWQsDQogICAgICAgICAgICAgICAgeTogdW5kZWZpbmVkDQogICAgICAgICAgICB9DQogICAgICAgIH0sDQogICAgfSwNCiAgICBtZXRob2RzOiB7DQogICAgICAgIHRvdWNoT24oZXZlbnQpew0KICAgICAgICAgICAgdGhpcy5pbml0aWFsVG91Y2hQb3MueCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7DQogICAgICAgICAgICB0aGlzLmluaXRpYWxUb3VjaFBvcy55ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTsNCiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RvdWNoT24nKTsNCiAgICAgICAgfSwNCiAgICAgICAgdG91Y2hPZmYoKXsNCiAgICAgICAgICAgIHRoaXMudG91Y2hTZWxlY3QgPSBmYWxzZTsNCiAgICAgICAgICAgIHRoaXMuY3VycmVudFRvdWNoUG9zLnggPSB1bmRlZmluZWQ7DQogICAgICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaFBvcy55ID0gdW5kZWZpbmVkOw0KICAgICAgICAgICAgdGhpcy5pbml0aWFsVG91Y2hQb3MueCA9IHVuZGVmaW5lZDsNCiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFRvdWNoUG9zLnkgPSB1bmRlZmluZWQ7DQogICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0b3VjaE9mZicpOw0KICAgICAgICB9LA0KICAgICAgICB0b3VjaENoYW5nZShldmVudCl7DQogICAgICAgICAgICB0aGlzLnRvdWNoU2VsZWN0ID0gdHJ1ZTsNCiAgICAgICAgICAgIHRoaXMuY3VycmVudFRvdWNoUG9zLnggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYOw0KICAgICAgICAgICAgdGhpcy5jdXJyZW50VG91Y2hQb3MueSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7DQogICAgICAgIH0sDQogICAgICAgIG1vdXNlT3ZlcihldmVudCl7DQogICAgICAgICAgICB0aGlzLm1vdXNlLnggPSBldmVudC54Ow0KICAgICAgICAgICAgdGhpcy5tb3VzZS55ID0gZXZlbnQueTsNCiAgICAgICAgfSwNCiAgICAgICAgbW91c2VMZWF2ZSgpew0KICAgICAgICAgICAgdGhpcy5tb3VzZS54ID0gdW5kZWZpbmVkOw0KICAgICAgICAgICAgdGhpcy5tb3VzZS55ID0gdW5kZWZpbmVkOw0KICAgICAgICB9LA0KICAgICAgICBhY3RpdmF0ZVNlbGVjdCgpew0KICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVNlbGVjdCA9IHRydWU7DQogICAgICAgIH0sDQogICAgICAgIGNhbmNlbFNlbGVjdCgpew0KICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVNlbGVjdCA9IGZhbHNlOw0KICAgICAgICB9LA0KICAgIH0sDQogICAgbW91bnRlZCgpew0KICAgICAgICBsZXQgdm0gPSB0aGlzOw0KICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzJyk7DQogICAgICAgIGxldCBwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7DQogICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOw0KICAgICAgICBsZXQgbW91c2VYID0gbnVsbDsNCiAgICAgICAgbGV0IG1vdXNlWSA9IG51bGw7DQogICAgICAgIGxldCBjdXJyZW50VG91Y2hYID0gbnVsbDsNCiAgICAgICAgbGV0IGN1cnJlbnRUb3VjaFkgPSBudWxsOw0KICAgICAgICBsZXQgYyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOw0KICAgICAgICBsZXQgc2NhbGUgPSAxOw0KDQoNCiAgICAgICAgZnVuY3Rpb24gcmVzaXplKCl7DQogICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTsNCiAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTsNCiAgICAgICAgICAgIHJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7DQogICAgICAgICAgICANCiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5vZmZzZXRXaWR0aCooMS9zY2FsZSk7DQogICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50Lm9mZnNldEhlaWdodCooMS9zY2FsZSk7DQogICAgICAgICAgICANCiAgICAgICAgICAgIC8vY2VudHJlIGFib3V0IHg9MCwgeT0wDQogICAgICAgICAgICBjLnRyYW5zbGF0ZShjYW52YXMud2lkdGgvMiwgY2FudmFzLmhlaWdodC8yKTsNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgc2V0VGltZW91dChyZXNpemUsIDUwMCk7DQogICAgICAgIH0NCg0KICAgICAgICByZXNpemUoKTsNCiAgICAgICAgc2V0VGltZW91dChyZXNpemUsIDEwMCk7DQogICAgICAgICANCiAgICAgICAgIA0KDQogICAgICAgIC8vIGxldCBpbml0aWFsVG91Y2hYID0gdGhpcy5pbml0aWFsVG91Y2hQb3MueCAtIHJlY3QubGVmdDsNCiAgICAgICAgLy8gbGV0IGluaXRpYWxUb3VjaFkgPSB0aGlzLmluaXRpYWxUb3VjaFBvcy55IC0gcmVjdC50b3A7DQogICAgICAgIC8vd2luZG93UmVzaXplKCk7DQoNCg0KDQogICAgICAgIGZ1bmN0aW9uIHJvdGF0ZVNoYXBlKGFuZ2xlLCBjZW50cmUsIHBvaW50cyl7DQogICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFuZ2xlLCBjZW50cmUsIHBvaW50cyk7DQogICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBbcG9pbnRzW2ldWzBdKk1hdGguY29zKGFuZ2xlKSAtIHBvaW50c1tpXVsxXSpNYXRoLnNpbihhbmdsZSksIHBvaW50c1tpXVswXSpNYXRoLnNpbihhbmdsZSkgKyBwb2ludHNbaV1bMV0qTWF0aC5jb3MoYW5nbGUpXTsNCiAgICAgICAgICAgICAgICBwb2ludHNbaV1bMF0gPSBjZW50cmVbMF0gKyBwb2ludHNbaV1bMF07DQogICAgICAgICAgICAgICAgcG9pbnRzW2ldWzFdID0gY2VudHJlWzFdICsgcG9pbnRzW2ldWzFdOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHBvaW50czsNCiAgICAgICAgfQ0KDQogICAgICAgIA0KICAgICAgICBmdW5jdGlvbiBCYWxsKHgsIHksIGRlZmF1bHRSYWRpdXMsIGR4LCBkeSkgew0KICAgICAgICAgICAgdGhpcy54ID0geDsNCiAgICAgICAgICAgIHRoaXMueSA9IHk7DQogICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGRlZmF1bHRSYWRpdXM7DQogICAgICAgICAgICB0aGlzLnBhdGhJbmRleCA9IDA7DQogICAgICAgICAgICB0aGlzLnZlbG9jaXR5U2VsZWN0ID0gZmFsc2U7DQogICAgICAgICAgICB0aGlzLnRvdWNoSW50ZXJmYWNlID0gZmFsc2U7DQogICAgICAgICAgICB0aGlzLnRpbWVTaW5jZUNsaWNrID0gMTA7DQogICAgICAgICAgICB0aGlzLmJ1dHRvblN0ZXAgPSAwLjE7DQogICAgICAgICAgICB0aGlzLmFycm93Q29uZmlybWVkID0gZmFsc2U7DQogICAgICAgICAgICBsZXQgbmV3UGF0aCA9IGZhbHNlOw0KDQogICAgICAgICAgICBpZihkeCA9PSB1bmRlZmluZWQgfHwgZHkgPT0gdW5kZWZpbmVkKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2UgYWxsIG9yYml0IGluIGNpcmN1bGFyIG9yYml0cyBpbiBzYW1lIGRpcmVjdGlvbiBpbml0aWFsbHkgDQogICAgICAgICAgICAgICAgdGhpcy5keCA9IDA7DQogICAgICAgICAgICAgICAgdGhpcy5keSA9IDA7DQoNCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbWFzc0NlbnRyZXMubGVuZ3RoOyBpKyspeyAgDQogICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IE1hdGgucG93KE1hdGgucG93KHRoaXMueC1tYXNzQ2VudHJlc1tpXVswXSAsIDIpICsgTWF0aC5wb3codGhpcy55LW1hc3NDZW50cmVzW2ldWzFdLCAyKSwgMC41KTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5keSArPSAtaW5pdGlhbFZlbCptYXNzQ2VudHJlc1tpXVsyXSpNYXRoLmFicyhNYXRoLnBvdyh0aGlzLmRpc3QgLCAtMikpKihtYXNzQ2VudHJlc1tpXVswXS10aGlzLngpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbWFzc0NlbnRyZXMubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSBNYXRoLnBvdyhNYXRoLnBvdyh0aGlzLngtbWFzc0NlbnRyZXNbaV1bMF0gLCAyKSArIE1hdGgucG93KHRoaXMueS1tYXNzQ2VudHJlc1tpXVsxXSwgMiksIDAuNSk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZHggKz0gaW5pdGlhbFZlbCptYXNzQ2VudHJlc1tpXVsyXSpNYXRoLmFicyhNYXRoLnBvdyh0aGlzLmRpc3QgLCAtMikpKihtYXNzQ2VudHJlc1tpXVsxXS10aGlzLnkpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgdGhpcy5keCA9IGR4Ow0KICAgICAgICAgICAgICAgIHRoaXMuZHkgPSBkeTsNCiAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oZHgsIGR5KSAgew0KICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UG9zID0gW3RoaXMueCwgdGhpcy55XTsNCiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZlbCA9IFt0aGlzLmR4LCB0aGlzLmR5XTsNCiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnZlbG9jaXR5U2VsZWN0KTsNCiAgICAgICAgICAgICAgICBpZih0aGlzLnZlbG9jaXR5U2VsZWN0IHx8IG5ld1BhdGgpew0KICAgICAgICAgICAgICAgICAgICBpZihpc05hTihkeCkgfHwgaXNOYU4oZHkpKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZWwgPSBbdGhpcy54LCB0aGlzLnldOw0KICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZlbCA9IFtkeCwgZHldOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICANCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoVmVscyA9IFtdOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhDb29yZHMgPSBbXTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZSA9IDE7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGxldCBpdGVyYXRpb25zID0gMDsNCiAgICAgICAgICAgICAgICB0aGlzLm5ld0Nvb3JkcyA9IFtdOw0KICAgICAgICAgICAgICAgIHRoaXMubmV3VmVscyA9IFtdOw0KICAgICAgICAgICAgICAgIGxldCBzdGVwU2l6ZSA9IDE7DQogICAgICAgICAgICAgICAgdGhpcy5jbG9zZWRQYXRoID0gdHJ1ZTsNCiAgICAgICAgICAgICAgICBsZXQgcmV2ZXJzZU11bHRpcGxpZXIgPSAxOw0KICAgICAgICAgICAgICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IDIwMDAwOw0KICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwYXRoIGRyYXdpbmcnKTsNCg0KICAgICAgICAgICAgICAgIHdoaWxlKE1hdGgucG93KChNYXRoLnBvdyh0aGlzLngtY3VycmVudFBvc1swXSwgMikgKyBNYXRoLnBvdyh0aGlzLnktY3VycmVudFBvc1sxXSwyKSksMC41KSA+IDEgfHwgaXRlcmF0aW9ucyA8IDEwMCl7DQoNCiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvc1swXSArPSBjdXJyZW50VmVsWzBdICogcmV2ZXJzZU11bHRpcGxpZXIgKiBzdGVwU2l6ZTsNCiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvc1sxXSArPSBjdXJyZW50VmVsWzFdICogcmV2ZXJzZU11bHRpcGxpZXIgKiBzdGVwU2l6ZTsNCg0KICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbWFzc0NlbnRyZXMubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgPSBNYXRoLnBvdyhNYXRoLnBvdyhjdXJyZW50UG9zWzBdLW1hc3NDZW50cmVzW2ldWzBdICwgMikgKyBNYXRoLnBvdyhjdXJyZW50UG9zWzFdLW1hc3NDZW50cmVzW2ldWzFdLCAyKSwgMC41KTsNCg0KICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZlbFswXSA9IGN1cnJlbnRWZWxbMF0gKyByZXZlcnNlTXVsdGlwbGllciAqIG1hc3NDZW50cmVzW2ldWzJdKk1hdGguYWJzKE1hdGgucG93KGRpc3QgLCAtMykpKihtYXNzQ2VudHJlc1tpXVswXS1jdXJyZW50UG9zWzBdKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZWxbMV0gPSBjdXJyZW50VmVsWzFdICsgcmV2ZXJzZU11bHRpcGxpZXIgKiBtYXNzQ2VudHJlc1tpXVsyXSpNYXRoLmFicyhNYXRoLnBvdyhkaXN0ICwgLTMpKSoobWFzc0NlbnRyZXNbaV1bMV0tY3VycmVudFBvc1sxXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9zZWRQYXRoKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudmVsb2NpdHlTZWxlY3QgfHwgbmV3UGF0aCl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdDb29yZHMucHVzaChjdXJyZW50UG9zLnNsaWNlKCkpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmVscy5wdXNoKGN1cnJlbnRWZWwuc2xpY2UoKSk7DQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2V7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQ29vcmRzLnB1c2goY3VycmVudFBvcy5zbGljZSgpKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhWZWxzLnB1c2goY3VycmVudFZlbC5zbGljZSgpKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlew0KICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy52ZWxvY2l0eVNlbGVjdCB8fCBuZXdQYXRoKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0Nvb3Jkcy51bnNoaWZ0KGN1cnJlbnRQb3Muc2xpY2UoKSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdWZWxzLnVuc2hpZnQoY3VycmVudFZlbC5zbGljZSgpKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhDb29yZHMudW5zaGlmdChjdXJyZW50UG9zLnNsaWNlKCkpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFZlbHMudW5zaGlmdChjdXJyZW50VmVsLnNsaWNlKCkpOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9ucyArPSAxOw0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHJldmVyc2UgcGF0aCBmb3Igb3BlbiBwYXRoDQogICAgICAgICAgICAgICAgICAgIGlmKGl0ZXJhdGlvbnMgPiB0aGlzLm1heEl0ZXJhdGlvbnMgfHwgTWF0aC5wb3coTWF0aC5wb3coY3VycmVudFBvc1swXSwyKSArIE1hdGgucG93KGN1cnJlbnRQb3NbMV0sMiksMC41KSA8IHZtLnN1blJhZGl1cyl7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zOw0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZWRQYXRoID0gZmFsc2U7DQogICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnZlbG9jaXR5U2VsZWN0IHx8IG5ld1BhdGgpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBbdGhpcy54LCB0aGlzLnldOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZWwgPSBbZHgsIGR5XTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IFt0aGlzLngsIHRoaXMueV07DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZlbCA9IFt0aGlzLmR4LCB0aGlzLmR5XTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMgPSAwOw0KICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICBpZihyZXZlcnNlTXVsdGlwbGllciA8IDApew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTXVsdGlwbGllciA9IC0xOw0KICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JldmVyc2UnKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgLy9DYWxsIHNjYWxpbmcgbWV0aG9kDQogICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDU7IGkrKyl7ICANCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZUNhbnZhcygpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICByZXNpemUoKTsNCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICBuZXdQYXRoID0gZmFsc2U7DQoNCg0KICAgICAgICAgICAgICAgIC8vRmluZCBtYXggcmFkaXVzIG9mIHBhdGgNCiAgICAgICAgICAgICAgICBsZXQgbWF4UmFkaXVzID0gMDsNCiAgICAgICAgICAgICAgICBsZXQgbWluUmFkaXVzID0gMTAwMDAwMDA7DQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgaWYodGhpcy5uZXdDb29yZHMubGVuZ3RoID4gMCl7DQogICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPHRoaXMubmV3Q29vcmRzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5wb3coTWF0aC5wb3codGhpcy5uZXdDb29yZHNbaV1bMF0sMikrTWF0aC5wb3codGhpcy5uZXdDb29yZHNbaV1bMV0sMiksMC41KTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpc3QgPiBtYXhSYWRpdXMpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFJhZGl1cyA9IGRpc3Q7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBpZihkaXN0IDwgbWluUmFkaXVzKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5SYWRpdXMgPSBkaXN0Ow0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8dGhpcy5wYXRoQ29vcmRzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5wb3coTWF0aC5wb3codGhpcy5wYXRoQ29vcmRzW2ldWzBdLDIpK01hdGgucG93KHRoaXMucGF0aENvb3Jkc1tpXVsxXSwyKSwwLjUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGlzdCA+IG1heFJhZGl1cyl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UmFkaXVzID0gZGlzdDsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpc3QgPCBtaW5SYWRpdXMpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblJhZGl1cyA9IGRpc3Q7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICANCiAgICAgICAgICAgICAgICB2bS4kZW1pdCgncGF0aC11cGRhdGUnLCBbY3VycmVudFBvcywgY3VycmVudFZlbCwgbWF4UmFkaXVzLCBtaW5SYWRpdXNdKTsNCiAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgdGhpcy5zY2FsZUNhbnZhcyA9IGZ1bmN0aW9uKCkgew0KICAgICAgICAgICAgICAgIC8vIFNjYWxpbmcNCiAgICAgICAgICAgICAgICBsZXQgbWF4WCA9IHRoaXMucGF0aENvb3Jkc1swXVswXTsNCiAgICAgICAgICAgICAgICBsZXQgbWF4WSA9IHRoaXMucGF0aENvb3Jkc1swXVsxXTsNCiAgICAgICAgICAgICAgICBsZXQgbWluWCA9IHRoaXMucGF0aENvb3Jkc1swXVswXTsNCiAgICAgICAgICAgICAgICBsZXQgbWluWSA9IHRoaXMucGF0aENvb3Jkc1swXVsxXTsNCg0KICAgICAgICAgICAgICAgIGlmKHRoaXMubmV3Q29vcmRzLmxlbmd0aCA+IDApew0KICAgICAgICAgICAgICAgICAgICBtYXhYID0gdGhpcy5uZXdDb29yZHNbMF1bMF07DQogICAgICAgICAgICAgICAgICAgIG1heFkgPSB0aGlzLm5ld0Nvb3Jkc1swXVsxXTsNCiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHRoaXMubmV3Q29vcmRzWzBdWzBdOw0KICAgICAgICAgICAgICAgICAgICBtaW5ZID0gdGhpcy5uZXdDb29yZHNbMF1bMV07DQoNCiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5ld0Nvb3Jkcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5uZXdDb29yZHNbaV0NCg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkWzBdID4gbWF4WCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSBjb29yZFswXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvb3JkWzBdIDwgbWluWCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSBjb29yZFswXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkWzFdID4gbWF4WSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBjb29yZFsxXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvb3JkWzFdIDwgbWluWSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBjb29yZFsxXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0gZWxzZXsNCiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHRoaXMucGF0aENvb3Jkc1swXVswXTsNCiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHRoaXMucGF0aENvb3Jkc1swXVsxXTsNCiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHRoaXMucGF0aENvb3Jkc1swXVswXTsNCiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHRoaXMucGF0aENvb3Jkc1swXVsxXTsNCg0KICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aENvb3Jkcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5wYXRoQ29vcmRzW2ldDQoNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb29yZFswXSA+IG1heFgpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gY29vcmRbMF07DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb29yZFswXSA8IG1pblgpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5YID0gY29vcmRbMF07DQogICAgICAgICAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb29yZFsxXSA+IG1heFkpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhZID0gY29vcmRbMV07DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb29yZFsxXSA8IG1pblkpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5ZID0gY29vcmRbMV07DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICBpZihtYXhYIDwgY2FudmFzLndpZHRoKigxL3RoaXMuc2NhbGUpLzQgJiYgbWF4WSA8IGNhbnZhcy5oZWlnaHQqKDEvdGhpcy5zY2FsZSkvNCAmJiBtaW5YID4gLWNhbnZhcy53aWR0aCooMS90aGlzLnNjYWxlKS80ICYmIG1pblkgPiAtY2FudmFzLmhlaWdodCooMS90aGlzLnNjYWxlKS80KXsNCiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG93bnNpemUnLCBtYXhYLCBtaW5YLCBjYW52YXMud2lkdGgqKDEvdGhpcy5zY2FsZSkvNCwgbWF4WSwgbWluWSwgY2FudmFzLmhlaWdodCooMS90aGlzLnNjYWxlKS80KTsNCiAgICAgICAgICAgICAgICAgICAgLy91bnNjYWxlDQogICAgICAgICAgICAgICAgICAgIGMuc2NhbGUoKDEvdGhpcy5zY2FsZSksICgxL3RoaXMuc2NhbGUpKTsNCiAgICAgICAgICAgICAgICAgICAgLy8gYy50cmFuc2xhdGUoY2FudmFzLndpZHRoLzQsIGNhbnZhcy5oZWlnaHQvNCk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLnNjYWxlKjI7DQogICAgICAgICAgICAgICAgICAgIC8vYy5zY2FsZSh0aGlzLnNjYWxlLCB0aGlzLnNjYWxlKTsgcmVzY2FsZSBkb25lIGJ5IHJlc2l6ZSgpDQogICAgICAgICAgICAgICAgfWVsc2UgaWYobWF4WCA+IGNhbnZhcy53aWR0aCooMS90aGlzLnNjYWxlKS8yIHx8IG1heFkgPiBjYW52YXMuaGVpZ2h0KigxL3RoaXMuc2NhbGUpLzIgfHwgbWluWCA8IC1jYW52YXMud2lkdGgqKDEvdGhpcy5zY2FsZSkvMiB8fCBtaW5ZIDwgLWNhbnZhcy5oZWlnaHQqKDEvdGhpcy5zY2FsZSkvMil7DQogICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Vwc2l6ZScsIG1heFgsIG1pblgsIGNhbnZhcy53aWR0aCooMS90aGlzLnNjYWxlKS80LCBtYXhZLCBtaW5ZLCBjYW52YXMuaGVpZ2h0KigxL3RoaXMuc2NhbGUpLzQpOw0KICAgICAgICAgICAgICAgICAgICAvL3Vuc2NhbGUNCiAgICAgICAgICAgICAgICAgICAgYy5zY2FsZSgoMS90aGlzLnNjYWxlKSwgKDEvdGhpcy5zY2FsZSkpOw0KICAgICAgICAgICAgICAgICAgICAvLyBjLnRyYW5zbGF0ZShjYW52YXMud2lkdGgvNCwgY2FudmFzLmhlaWdodC80KTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuc2NhbGUvMjsNCiAgICAgICAgICAgICAgICAgICAgLy9jLnNjYWxlKHRoaXMuc2NhbGUsIHRoaXMuc2NhbGUpOyByZXNjYWxlIGRvbmUgYnkgcmVzaXplKCkNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgc2NhbGUgPSB0aGlzLnNjYWxlOw0KICAgICAgICAgICAgICAgIHJlc2l6ZSgpOw0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbigpIHsNCiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGRlZmF1bHRSYWRpdXMqKDEvdGhpcy5zY2FsZSk7DQogICAgICAgICAgICAgICAgbGV0IGFycm93T2Zmc2V0ID0gdGhpcy5yYWRpdXMqMzsNCg0KICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgYy5tb3ZlVG8odGhpcy5wYXRoQ29vcmRzWzBdWzBdLCB0aGlzLnBhdGhDb29yZHNbMF1bMV0pOw0KICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLnBhdGhDb29yZHMubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyh0aGlzLnBhdGhDb29yZHNbaV1bMF0sIHRoaXMucGF0aENvb3Jkc1tpXVsxXSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmKHRoaXMuY2xvc2VkUGF0aCl7DQogICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHRoaXMucGF0aENvb3Jkc1swXVswXSwgdGhpcy5wYXRoQ29vcmRzWzBdWzFdKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSAyKigxL3RoaXMuc2NhbGUpOw0KICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAiYmxhY2siOw0KICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7DQoNCiAgICAgICAgICAgICAgICBpZih0aGlzLnZlbG9jaXR5U2VsZWN0ICYmIHRoaXMubmV3Q29vcmRzLmxlbmd0aCA+IDApew0KICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyh0aGlzLm5ld0Nvb3Jkc1swXVswXSwgdGhpcy5uZXdDb29yZHNbMF1bMV0pOw0KICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5uZXdDb29yZHMubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8odGhpcy5uZXdDb29yZHNbaV1bMF0sIHRoaXMubmV3Q29vcmRzW2ldWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNsb3NlZFBhdGgpew0KICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8odGhpcy5uZXdDb29yZHNbMF1bMF0sIHRoaXMubmV3Q29vcmRzWzBdWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDIqKDEvdGhpcy5zY2FsZSk7DQogICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAiYmx1ZSI7DQogICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7DQogICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgICAgICBjLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIDAsIDIqTWF0aC5QSSk7DQogICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiKDAsMCwyNTUpJzsNCiAgICAgICAgICAgICAgICBjLmZpbGwoKTsNCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICBpZih0aGlzLnZlbG9jaXR5U2VsZWN0KXsNCiAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgICAgICAgICAgYy5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzKjEuNSwgMCwgMipNYXRoLlBJKTsNCiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiKDAsMjU1LDApJzsNCiAgICAgICAgICAgICAgICAgICAgYy5maWxsKCk7DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy50YW5BbmdsZSA9IE1hdGguYXRhbjIodGhpcy5wYXRoQ29vcmRzW3RoaXMucGF0aEluZGV4KzFdWzFdLSB0aGlzLnBhdGhDb29yZHNbdGhpcy5wYXRoSW5kZXgtMV1bMV0sIHRoaXMucGF0aENvb3Jkc1t0aGlzLnBhdGhJbmRleCsxXVswXS0gdGhpcy5wYXRoQ29vcmRzW3RoaXMucGF0aEluZGV4LTFdWzBdKTsNCg0KICAgICAgICAgICAgICAgICAgICB0aGlzLmFycm93Q2VudHJlcyA9IFtdOw0KICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgNDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dDZW50cmVzLnB1c2goW3RoaXMueCArIHRoaXMucmFkaXVzKjQqTWF0aC5jb3ModGhpcy50YW5BbmdsZSArIGkqTWF0aC5QSS8yKSwgdGhpcy55ICsgdGhpcy5yYWRpdXMqNCpNYXRoLnNpbih0aGlzLnRhbkFuZ2xlICsgaSpNYXRoLlBJLzIpXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgICAgICAgICB0aGlzLnRhblBvaW50czEgPSByb3RhdGVTaGFwZSh0aGlzLnRhbkFuZ2xlLCBbdGhpcy54LCB0aGlzLnldLCBbW2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1cyoyXSwgW3RoaXMucmFkaXVzKjMrYXJyb3dPZmZzZXQsIDBdLA0KICAgICAgICAgICAgICAgICAgICBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzKjJdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzXSwgW2Fycm93T2Zmc2V0LCAtdGhpcy5yYWRpdXNdXSk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMudGFuUG9pbnRzMiA9IHJvdGF0ZVNoYXBlKHRoaXMudGFuQW5nbGUgKyBNYXRoLlBJLCBbdGhpcy54LCB0aGlzLnldLCBbW2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1cyoyXSwgW3RoaXMucmFkaXVzKjMrYXJyb3dPZmZzZXQsIDBdLA0KICAgICAgICAgICAgICAgICAgICBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzKjJdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzXSwgW2Fycm93T2Zmc2V0LCAtdGhpcy5yYWRpdXNdXSk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMucm90UG9pbnRzMSA9IHJvdGF0ZVNoYXBlKHRoaXMudGFuQW5nbGUgKyBNYXRoLlBJLzIsIFt0aGlzLngsIHRoaXMueV0sIFtbYXJyb3dPZmZzZXQsIHRoaXMucmFkaXVzXSwgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIHRoaXMucmFkaXVzXSwgW3RoaXMucmFkaXVzKjIrYXJyb3dPZmZzZXQsIHRoaXMucmFkaXVzKjJdLCBbdGhpcy5yYWRpdXMqMythcnJvd09mZnNldCwgMF0sDQogICAgICAgICAgICAgICAgICAgIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCAtdGhpcy5yYWRpdXMqMl0sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCAtdGhpcy5yYWRpdXNdLCBbYXJyb3dPZmZzZXQsIC10aGlzLnJhZGl1c11dKTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3RQb2ludHMyID0gcm90YXRlU2hhcGUodGhpcy50YW5BbmdsZSArIDMqTWF0aC5QSS8yLCBbdGhpcy54LCB0aGlzLnldLCBbW2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1c10sIFt0aGlzLnJhZGl1cyoyK2Fycm93T2Zmc2V0LCB0aGlzLnJhZGl1cyoyXSwgW3RoaXMucmFkaXVzKjMrYXJyb3dPZmZzZXQsIDBdLA0KICAgICAgICAgICAgICAgICAgICBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzKjJdLCBbdGhpcy5yYWRpdXMqMithcnJvd09mZnNldCwgLXRoaXMucmFkaXVzXSwgW2Fycm93T2Zmc2V0LCAtdGhpcy5yYWRpdXNdXSk7DQoNCiAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8odGhpcy50YW5Qb2ludHMxWzBdWzBdLCB0aGlzLnRhblBvaW50czFbMF1bMV0pOw0KICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy50YW5Qb2ludHMxLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHRoaXMudGFuUG9pbnRzMVtpXVswXSwgdGhpcy50YW5Qb2ludHMxW2ldWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdibHVlJzsNCiAgICAgICAgICAgICAgICAgICAgYy5maWxsKCk7DQoNCiAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTsNCiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8odGhpcy50YW5Qb2ludHMyWzBdWzBdLCB0aGlzLnRhblBvaW50czJbMF1bMV0pOw0KICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy50YW5Qb2ludHMyLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHRoaXMudGFuUG9pbnRzMltpXVswXSwgdGhpcy50YW5Qb2ludHMyW2ldWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdibHVlJzsNCiAgICAgICAgICAgICAgICAgICAgYy5maWxsKCk7DQoNCg0KICAgICAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyh0aGlzLnJvdFBvaW50czFbMF1bMF0sIHRoaXMucm90UG9pbnRzMVswXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLnJvdFBvaW50czEubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8odGhpcy5yb3RQb2ludHMxW2ldWzBdLCB0aGlzLnJvdFBvaW50czFbaV1bMV0pOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3B1cnBsZSc7DQogICAgICAgICAgICAgICAgICAgIGMuZmlsbCgpOw0KDQogICAgICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHRoaXMucm90UG9pbnRzMlswXVswXSwgdGhpcy5yb3RQb2ludHMyWzBdWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHRoaXMucm90UG9pbnRzMi5sZW5ndGg7IGkrKyl7DQogICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyh0aGlzLnJvdFBvaW50czJbaV1bMF0sIHRoaXMucm90UG9pbnRzMltpXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncHVycGxlJzsNCiAgICAgICAgICAgICAgICAgICAgYy5maWxsKCk7DQogICAgICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICAgICAgaWYodm0udG91Y2hTZWxlY3Qpew0KICAgICAgICAgICAgICAgICAgICAvLyBsZXQgZGlzcFggPSBjdXJyZW50VG91Y2hYIC0gaW5pdGlhbFRvdWNoWDsNCiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGRpc3BZID0gY3VycmVudFRvdWNoWSAtIGluaXRpYWxUb3VjaFk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubWFnID0gTWF0aC5wb3coTWF0aC5wb3coY3VycmVudFRvdWNoWC0gdGhpcy54LCAyKSArIE1hdGgucG93KGN1cnJlbnRUb3VjaFktdGhpcy55LCAyKSwgMC41KTsNCiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5tYWcgPiB0aGlzLnJhZGl1cyoyMCl7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hZyA9IHRoaXMucmFkaXVzKjIwOw0KICAgICAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJvd0FuZ2xlID0gTWF0aC5hdGFuMihjdXJyZW50VG91Y2hZIC0gdGhpcy55LCBjdXJyZW50VG91Y2hYIC0gdGhpcy54KTsNCg0KICAgICAgICAgICAgICAgICAgICB0aGlzLmFycm93UG9pbnRzID0gcm90YXRlU2hhcGUodGhpcy5hcnJvd0FuZ2xlLCBbdGhpcy54LCB0aGlzLnldLCBbWzAsMF0sIFt0aGlzLm1hZywgdGhpcy5yYWRpdXMqMl0sIFt0aGlzLm1hZywgdGhpcy5yYWRpdXMqNl0sIFt0aGlzLm1hZyArIHRoaXMucmFkaXVzKjYsIDBdLFt0aGlzLm1hZywgLXRoaXMucmFkaXVzKjZdICxbdGhpcy5tYWcsIC10aGlzLnJhZGl1cyoyXV0pOw0KDQogICAgICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHRoaXMueCwgdGhpcy55KTsNCiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYXJyb3dQb2ludHMubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8odGhpcy5hcnJvd1BvaW50c1tpXVswXSwgdGhpcy5hcnJvd1BvaW50c1tpXVsxXSk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgwLCAyNTUsIDAsIDAuNyknOw0KICAgICAgICAgICAgICAgICAgICBjLmZpbGwoKTsNCg0KICAgICAgICAgICAgICAgICAgICB0aGlzLmFycm93Q29uZmlybWVkID0gdHJ1ZTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24oKSB7DQoNCiAgICAgICAgICAgICAgICB0aGlzLnRpbWVTaW5jZUNsaWNrICs9IDE7IA0KICAgICAgICAgICAgICAgIHRoaXMuZHJhdygpOw0KDQogICAgICAgICAgICAgICAgaWYodGhpcy5wYXRoSW5kZXggPj0gdGhpcy5wYXRoQ29vcmRzLmxlbmd0aCl7DQogICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aEluZGV4PTE7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIGlmKCF0aGlzLnZlbG9jaXR5U2VsZWN0ICYmICF2bS50b3VjaFNlbGVjdCl7DQogICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMucGF0aENvb3Jkc1t0aGlzLnBhdGhJbmRleF1bMF07DQogICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMucGF0aENvb3Jkc1t0aGlzLnBhdGhJbmRleF1bMV07DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZHggPSB0aGlzLnBhdGhWZWxzW3RoaXMucGF0aEluZGV4XVswXTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5keSA9IHRoaXMucGF0aFZlbHNbdGhpcy5wYXRoSW5kZXhdWzFdOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhJbmRleCArPSB2bS5hbmltYXRpb25TcGVlZDsNCiAgICAgICAgICAgICAgICAgICAgdm0uJGVtaXQoJ3Bvc2l0aW9uLXVwZGF0ZScsIFt0aGlzLngsIHRoaXMueV0pOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICBpZih2bS52ZWxvY2l0eVNlbGVjdCAmJiBNYXRoLnBvdygoTWF0aC5wb3coKG1vdXNlWC10aGlzLngpLDIpICsgTWF0aC5wb3coKG1vdXNlWS10aGlzLnkpLDIpKSwxLzIpIDwgdGhpcy5yYWRpdXMqMS41ICYmIHRoaXMudGltZVNpbmNlQ2xpY2sgPiAyMCl7DQogICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudmVsb2NpdHlTZWxlY3QgJiYgdGhpcy5uZXdDb29yZHMubGVuZ3RoID4gMCl7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhDb29yZHMgPSB0aGlzLm5ld0Nvb3JkczsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFZlbHMgPSB0aGlzLm5ld1ZlbHM7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0Nvb3JkcyA9IFtdOw0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdWZWxzID0gW107DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhJbmRleCA9IDE7IA0KICAgICAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lU2luY2VDbGljayA9IDA7DQogICAgICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHlTZWxlY3QgPSAhdGhpcy52ZWxvY2l0eVNlbGVjdDsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgaWYodGhpcy52ZWxvY2l0eVNlbGVjdCl7DQogICAgICAgICAgICAgICAgICAgIC8vIGlmKGJhbGxBcnJheS5sZW5ndGggPSAxKXsNCiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJhbGxBcnJheS5wdXNoKG5ldyBCYWxsKGNhbnZhcy53aWR0aC8zLCBjYW52YXMuaGVpZ2h0LzMsIDEwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCkpOw0KICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy9jb25zb2xlLmxvZyhiYWxsQXJyYXkpOw0KICAgICAgICAgICAgICAgICAgICAvLyB9DQogICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmFycm93Q2VudHJlcy5sZW5ndGg7IGkrKyl7DQogICAgICAgICAgICAgICAgICAgICAgICBpZih2bS52ZWxvY2l0eVNlbGVjdCAmJiBNYXRoLnBvdygoTWF0aC5wb3coKG1vdXNlWC10aGlzLmFycm93Q2VudHJlc1tpXVswXSksMikgKyBNYXRoLnBvdygobW91c2VZLXRoaXMuYXJyb3dDZW50cmVzW2ldWzFdKSwyKSksMS8yKSA8IHRoaXMucmFkaXVzKjIgJiYgdGhpcy50aW1lU2luY2VDbGljayA+IDIwKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVTaW5jZUNsaWNrID0gMDsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpID09IDApew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGFuZ2VudGlhbCBvdXQnKTsgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHggKz0gdGhpcy5idXR0b25TdGVwICogTWF0aC5jb3ModGhpcy50YW5BbmdsZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHkgKz0gdGhpcy5idXR0b25TdGVwICogTWF0aC5zaW4odGhpcy50YW5BbmdsZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkgPT0gMSl7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyYWRpYWwgaW4nKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeCArPSB0aGlzLmJ1dHRvblN0ZXAgKiBNYXRoLnNpbih0aGlzLnRhbkFuZ2xlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeSArPSB0aGlzLmJ1dHRvblN0ZXAgKiBNYXRoLmNvcyh0aGlzLnRhbkFuZ2xlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaSA9PSAyKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RhbmdlbnRpYWwgaW4nKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeCArPSAtdGhpcy5idXR0b25TdGVwICogTWF0aC5jb3ModGhpcy50YW5BbmdsZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHkgKz0gLXRoaXMuYnV0dG9uU3RlcCAqIE1hdGguc2luKHRoaXMudGFuQW5nbGUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpID09IDMpew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmFkaWFsIG91dCcpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R4ICs9IC10aGlzLmJ1dHRvblN0ZXAgKiBNYXRoLnNpbih0aGlzLnRhbkFuZ2xlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdkeSArPSAtdGhpcy5idXR0b25TdGVwICogTWF0aC5jb3ModGhpcy50YW5BbmdsZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhcnJvdyBQcmVzcycpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCh0aGlzLm5ld2R4LCB0aGlzLm5ld2R5KTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubmV3ZHggPSB0aGlzLmR4Ow0KICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R5ID0gdGhpcy5keTsNCiAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAvL0NoYW5nZSB2ZWxvY2l0eSBhbmQgZHJhdyBuZXcgcGF0aCB3aGVuIHRvdWNoIHJlbGVhc2VkDQogICAgICAgICAgICAgICAgaWYoIXZtLnRvdWNoU2VsZWN0ICYmIHRoaXMuYXJyb3dDb25maXJtZWQpew0KICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R4ID0gdGhpcy5keCArIChNYXRoLmNvcyh0aGlzLmFycm93QW5nbGUpKSAqICgwLjAwMDUqdGhpcy5tYWcvdGhpcy5yYWRpdXMqMjApOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld2R5ID0gdGhpcy5keSArIChNYXRoLnNpbih0aGlzLmFycm93QW5nbGUpKSAqICgwLjAwMDUqdGhpcy5tYWcvdGhpcy5yYWRpdXMqMjApOw0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgbmV3UGF0aCA9IHRydWU7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Q29vcmRzID0gW107DQogICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmVscyA9IFtdOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGgodGhpcy5uZXdkeCwgdGhpcy5uZXdkeSk7Ow0KDQogICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubmV3Q29vcmRzLmxlbmd0aCA+IDApew0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoQ29vcmRzID0gdGhpcy5uZXdDb29yZHM7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhWZWxzID0gdGhpcy5uZXdWZWxzOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jbG9zZWRQYXRoKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhJbmRleCA9IDE7IA0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aEluZGV4ID0gTWF0aC5yb3VuZCh0aGlzLnBhdGhDb29yZHMubGVuZ3RoLzIpOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQoNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnJvd0NvbmZpcm1lZCA9IGZhbHNlOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICANCiAgICAgICAgLy9sZXQgbWF4UmFkaXVzID0gMzA7DQogICAgICAgIC8vbGV0IG1vdXNlUmFkaXVzID0gNTU7DQogICAgICAgIGxldCBiYWxsQXJyYXkgPSBbXTsNCg0KICAgICAgICAvLyBbW3gseSwgbWFzc11dDQogICAgICAgIC8vbGV0IG1hc3NDZW50cmVzID0gW1tjYW52YXMud2lkdGgvMywgY2FudmFzLmhlaWdodC8zXSwgWzIqY2FudmFzLndpZHRoLzMsIGNhbnZhcy5oZWlnaHQvM10sIFtjYW52YXMud2lkdGgvMiwgMipjYW52YXMuaGVpZ2h0LzNdXTsNCiAgICAgICAgbGV0IG1hc3NDZW50cmVzID0gW1swLCAwICwgMTAwXV07DQogICAgICAgIGxldCBpbml0aWFsVmVsID0gMTsNCg0KICAgICAgICBiYWxsQXJyYXkucHVzaChuZXcgQmFsbChjYW52YXMud2lkdGgvMywgY2FudmFzLmhlaWdodC8zLCA1LCB1bmRlZmluZWQsIHVuZGVmaW5lZCkpOw0KICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmFsbEFycmF5Lmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgIGJhbGxBcnJheVtpXS5wYXRoKCk7DQogICAgICAgIH0NCg0KICAgICAgICBmdW5jdGlvbiBhbmltYXRlKCkgew0KICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpOw0KDQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGxBcnJheS5sZW5ndGg7IGkrKyl7DQoNCiAgICAgICAgICAgICAgICAvLyBJZiBzdGF0ZW1lbnQgZml4ZXMgYnVnIG9mIHJlY3Qgbm90IGZ1bGx5IGNsZWFyaW5nIHdoZW4gc2NhbGUgc21hbGwNCiAgICAgICAgICAgICAgICBpZigxL2JhbGxBcnJheVtpXS5zY2FsZSA+PSAxKXsNCiAgICAgICAgICAgICAgICBjLmNsZWFyUmVjdCgtY2FudmFzLndpZHRoKigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMiwgLWNhbnZhcy5oZWlnaHQqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yLCBjYW52YXMud2lkdGgqKDEvYmFsbEFycmF5W2ldLnNjYWxlKSwgY2FudmFzLmhlaWdodCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpKTsNCiAgICAgICAgICAgICAgICB9IGVsc2V7DQogICAgICAgICAgICAgICAgICAgIGMuY2xlYXJSZWN0KC1jYW52YXMud2lkdGgvMiwgLWNhbnZhcy5oZWlnaHQvMiwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgLy9ib3VuZGluZyBib3gNCiAgICAgICAgICAgICAgICAvLyBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgICAgIC8vIGMubW92ZVRvKC1jYW52YXMud2lkdGgqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yLCAtY2FudmFzLmhlaWdodCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpLzIpOw0KICAgICAgICAgICAgICAgIC8vIGMubGluZVRvKGNhbnZhcy53aWR0aCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpLzIsIC1jYW52YXMuaGVpZ2h0KigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMik7DQogICAgICAgICAgICAgICAgLy8gYy5saW5lVG8oY2FudmFzLndpZHRoKigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMiwgY2FudmFzLmhlaWdodCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpLzIpOw0KICAgICAgICAgICAgICAgIC8vIGMubGluZVRvKC1jYW52YXMud2lkdGgqKDEvYmFsbEFycmF5W2ldLnNjYWxlKS8yLCBjYW52YXMuaGVpZ2h0KigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMik7DQogICAgICAgICAgICAgICAgLy8gYy5saW5lVG8oLWNhbnZhcy53aWR0aCooMS9iYWxsQXJyYXlbaV0uc2NhbGUpLzIsIC1jYW52YXMuaGVpZ2h0KigxL2JhbGxBcnJheVtpXS5zY2FsZSkvMik7DQogICAgICAgICAgICAgICAgLy8gYy5saW5lV2lkdGggPSAxOw0KICAgICAgICAgICAgICAgIC8vIGMuc3Ryb2tlKCk7DQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIG1vdXNlWCA9ICh2bS5tb3VzZS54IC0gcmVjdC5sZWZ0KSooMS9iYWxsQXJyYXlbMF0uc2NhbGUpIC0gY2FudmFzLndpZHRoLzI7DQogICAgICAgICAgICBtb3VzZVkgPSAodm0ubW91c2UueSAtIHJlY3QudG9wICkqKDEvYmFsbEFycmF5WzBdLnNjYWxlKSAtIGNhbnZhcy5oZWlnaHQvMjsNCiAgICAgICAgICAgIGN1cnJlbnRUb3VjaFggPSAodm0uY3VycmVudFRvdWNoUG9zLnggLSByZWN0LmxlZnQpKigxL2JhbGxBcnJheVswXS5zY2FsZSkgLSBjYW52YXMud2lkdGgvMjsNCiAgICAgICAgICAgIGN1cnJlbnRUb3VjaFkgPSAodm0uY3VycmVudFRvdWNoUG9zLnkgLSByZWN0LnRvcCkqKDEvYmFsbEFycmF5WzBdLnNjYWxlKSAtIGNhbnZhcy5oZWlnaHQvMjsNCiAgICAgICAgICAgIC8vIGluaXRpYWxUb3VjaFggPSAodm0uaW5pdGlhbFRvdWNoUG9zLnggLSByZWN0LmxlZnQgLSBjYW52YXMud2lkdGgvMikqKDEvYmFsbEFycmF5WzBdLnNjYWxlKTsNCiAgICAgICAgICAgIC8vIGluaXRpYWxUb3VjaFkgPSAodm0uaW5pdGlhbFRvdWNoUG9zLnkgLSByZWN0LnRvcCAtIGNhbnZhcy5oZWlnaHQvMikqKDEvYmFsbEFycmF5WzBdLnNjYWxlKTsNCg0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYWxsQXJyYXkubGVuZ3RoOyBpKyspew0KICAgICAgICAgICAgICAgIGJhbGxBcnJheVtpXS51cGRhdGUoKTsNCiAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPG1hc3NDZW50cmVzLmxlbmd0aDsgaSsrKXsNCiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgICAgIGMuYXJjKG1hc3NDZW50cmVzW2ldWzBdLCBtYXNzQ2VudHJlc1tpXVsxXSwgdm0uc3VuUmFkaXVzLCAwLCBNYXRoLlBJICogMik7IA0KICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ09yYW5nZSc7DQogICAgICAgICAgICAgICAgYy5maWxsKCk7DQogICAgICAgICAgICB9DQoNCiAgICAgICAgICAgIC8vIGMuYmVnaW5QYXRoKCk7DQogICAgICAgICAgICAvLyBjLmFyYyhtb3VzZVgsIG1vdXNlWSwgMjAsIDAsIE1hdGguUEkgKiAyKTsNCiAgICAgICAgICAgIC8vIGMuZmlsbFN0eWxlID0gImJsYWNrIjsNCiAgICAgICAgICAgIC8vIGMuZmlsbCgpOw0KICAgICAgICAgICAgDQogICAgICAgICAgICAvLyBjLmJlZ2luUGF0aCgpOw0KICAgICAgICAgICAgLy8gYy5hcmMoMjMxNiwgNjY5LCA1MDAsIDAsIE1hdGguUEkgKiAyKTsgDQogICAgICAgICAgICAvLyBjLmZpbGxTdHlsZSA9ICdSZWQnOw0KICAgICAgICAgICAgLy8gYy5maWxsKCk7DQogICAgICAgICAgICANCiAgICAgICAgfQ0KDQogICAgICAgIGFuaW1hdGUoKTsNCg0KICAgIH0NCg0KfQ0K"},{"version":3,"sources":["Orbits.vue"],"names":[],"mappings":";;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA","file":"Orbits.vue","sourceRoot":"src/components","sourcesContent":["<template>\r\n    <div id=\"parent\" style=\"height:100%;\" @mousemove=\"mouseOver\" @mouseleave=\"mouseLeave\" @mousedown=\"activateSelect\" @mouseup=\"cancelSelect\" @touchstart=\"touchOn\" @touchend=\"touchOff\" @touchmove=\"touchChange\">\r\n         <canvas id=\"canvas\" style=\"width:100%; height:100%\" ></canvas>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name: 'iv-orbits',\r\n    props: {\r\n        mouse: {\r\n            default: {\r\n                x: undefined,\r\n                y: undefined\r\n            }\r\n        },\r\n        animationSpeed: {\r\n            default: 1\r\n        },\r\n        velocitySelect: {\r\n            default: false\r\n        },\r\n        sunRadius: {\r\n            default: 20\r\n        },\r\n        touchSelect: {\r\n            default: false\r\n        },\r\n        initialTouchPos:{\r\n            default: {\r\n                x: undefined,\r\n                y: undefined\r\n            }\r\n        },\r\n        currentTouchPos:{\r\n            default: {\r\n                x: undefined,\r\n                y: undefined\r\n            }\r\n        },\r\n    },\r\n    methods: {\r\n        touchOn(event){\r\n            this.initialTouchPos.x = event.touches[0].pageX;\r\n            this.initialTouchPos.y = event.touches[0].pageY;\r\n            //console.log('touchOn');\r\n        },\r\n        touchOff(){\r\n            this.touchSelect = false;\r\n            this.currentTouchPos.x = undefined;\r\n            this.currentTouchPos.y = undefined;\r\n            this.initialTouchPos.x = undefined;\r\n            this.initialTouchPos.y = undefined;\r\n            //console.log('touchOff');\r\n        },\r\n        touchChange(event){\r\n            this.touchSelect = true;\r\n            this.currentTouchPos.x = event.touches[0].pageX;\r\n            this.currentTouchPos.y = event.touches[0].pageY;\r\n        },\r\n        mouseOver(event){\r\n            this.mouse.x = event.x;\r\n            this.mouse.y = event.y;\r\n        },\r\n        mouseLeave(){\r\n            this.mouse.x = undefined;\r\n            this.mouse.y = undefined;\r\n        },\r\n        activateSelect(){\r\n            this.velocitySelect = true;\r\n        },\r\n        cancelSelect(){\r\n            this.velocitySelect = false;\r\n        },\r\n    },\r\n    mounted(){\r\n        let vm = this;\r\n        let canvas = document.querySelector('canvas');\r\n        let parent = document.getElementById('parent');\r\n        let rect = parent.getBoundingClientRect();\r\n        let mouseX = null;\r\n        let mouseY = null;\r\n        let currentTouchX = null;\r\n        let currentTouchY = null;\r\n        let c = canvas.getContext('2d');\r\n        let scale = 1;\r\n\r\n\r\n        function resize(){\r\n            canvas = document.querySelector('canvas');\r\n            parent = document.getElementById('parent');\r\n            rect = parent.getBoundingClientRect();\r\n            \r\n            canvas.width = parent.offsetWidth*(1/scale);\r\n            canvas.height = parent.offsetHeight*(1/scale);\r\n            \r\n            //centre about x=0, y=0\r\n            c.translate(canvas.width/2, canvas.height/2);\r\n            \r\n            setTimeout(resize, 500);\r\n        }\r\n\r\n        resize();\r\n        setTimeout(resize, 100);\r\n         \r\n         \r\n\r\n        // let initialTouchX = this.initialTouchPos.x - rect.left;\r\n        // let initialTouchY = this.initialTouchPos.y - rect.top;\r\n        //windowResize();\r\n\r\n\r\n\r\n        function rotateShape(angle, centre, points){\r\n            //console.log(angle, centre, points);\r\n            for(let i = 0; i < points.length; i++){\r\n                points[i] = [points[i][0]*Math.cos(angle) - points[i][1]*Math.sin(angle), points[i][0]*Math.sin(angle) + points[i][1]*Math.cos(angle)];\r\n                points[i][0] = centre[0] + points[i][0];\r\n                points[i][1] = centre[1] + points[i][1];\r\n            }\r\n            return points;\r\n        }\r\n\r\n        \r\n        function Ball(x, y, defaultRadius, dx, dy) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.radius = defaultRadius;\r\n            this.pathIndex = 0;\r\n            this.velocitySelect = false;\r\n            this.touchInterface = false;\r\n            this.timeSinceClick = 10;\r\n            this.buttonStep = 0.1;\r\n            this.arrowConfirmed = false;\r\n            let newPath = false;\r\n\r\n            if(dx == undefined || dy == undefined){\r\n                            //make all orbit in circular orbits in same direction initially \r\n                this.dx = 0;\r\n                this.dy = 0;\r\n\r\n                for(let i = 0; i < massCentres.length; i++){  \r\n                    this.dist = Math.pow(Math.pow(this.x-massCentres[i][0] , 2) + Math.pow(this.y-massCentres[i][1], 2), 0.5);\r\n                    this.dy += -initialVel*massCentres[i][2]*Math.abs(Math.pow(this.dist , -2))*(massCentres[i][0]-this.x);\r\n                }\r\n                for(let i = 0; i < massCentres.length; i++){\r\n                    this.dist = Math.pow(Math.pow(this.x-massCentres[i][0] , 2) + Math.pow(this.y-massCentres[i][1], 2), 0.5);\r\n                    this.dx += initialVel*massCentres[i][2]*Math.abs(Math.pow(this.dist , -2))*(massCentres[i][1]-this.y);\r\n                }\r\n            } else {\r\n                this.dx = dx;\r\n                this.dy = dy;\r\n            }\r\n\r\n            this.path = function(dx, dy)  {\r\n                let currentPos = [this.x, this.y];\r\n                let currentVel = [this.dx, this.dy];\r\n                console.log(this.velocitySelect);\r\n                if(this.velocitySelect || newPath){\r\n                    if(isNaN(dx) || isNaN(dy)){\r\n                        currentVel = [this.x, this.y];\r\n                    } else {\r\n                        currentVel = [dx, dy];\r\n                    }\r\n                } else {      \r\n                    this.pathVels = [];\r\n                    this.pathCoords = [];\r\n                    this.scale = 1;\r\n                }\r\n                let iterations = 0;\r\n                this.newCoords = [];\r\n                this.newVels = [];\r\n                let stepSize = 1;\r\n                this.closedPath = true;\r\n                let reverseMultiplier = 1;\r\n                this.maxIterations = 20000;\r\n                console.log('path drawing');\r\n\r\n                while(Math.pow((Math.pow(this.x-currentPos[0], 2) + Math.pow(this.y-currentPos[1],2)),0.5) > 1 || iterations < 100){\r\n\r\n                    currentPos[0] += currentVel[0] * reverseMultiplier * stepSize;\r\n                    currentPos[1] += currentVel[1] * reverseMultiplier * stepSize;\r\n\r\n                    for(let i = 0; i < massCentres.length; i++){\r\n                        let dist = Math.pow(Math.pow(currentPos[0]-massCentres[i][0] , 2) + Math.pow(currentPos[1]-massCentres[i][1], 2), 0.5);\r\n\r\n                        currentVel[0] = currentVel[0] + reverseMultiplier * massCentres[i][2]*Math.abs(Math.pow(dist , -3))*(massCentres[i][0]-currentPos[0]);\r\n                        currentVel[1] = currentVel[1] + reverseMultiplier * massCentres[i][2]*Math.abs(Math.pow(dist , -3))*(massCentres[i][1]-currentPos[1]);\r\n                    }\r\n\r\n                    if (this.closedPath){\r\n                        if(this.velocitySelect || newPath){\r\n                            this.newCoords.push(currentPos.slice());\r\n                            this.newVels.push(currentVel.slice());\r\n                        } else{\r\n                            this.pathCoords.push(currentPos.slice());\r\n                            this.pathVels.push(currentVel.slice());\r\n                        }\r\n                    } else{\r\n                        if(this.velocitySelect || newPath){\r\n                            this.newCoords.unshift(currentPos.slice());\r\n                            this.newVels.unshift(currentVel.slice());\r\n                        } else{\r\n                            this.pathCoords.unshift(currentPos.slice());\r\n                            this.pathVels.unshift(currentVel.slice());\r\n                        }\r\n                    }\r\n\r\n                    iterations += 1;\r\n                    \r\n                    //Draw reverse path for open path\r\n                    if(iterations > this.maxIterations || Math.pow(Math.pow(currentPos[0],2) + Math.pow(currentPos[1],2),0.5) < vm.sunRadius){\r\n                        this.maxIterations = iterations;\r\n                        this.closedPath = false;\r\n                        if(this.velocitySelect || newPath){\r\n                            currentPos = [this.x, this.y];\r\n                            currentVel = [dx, dy];\r\n                        } else {\r\n                            currentPos = [this.x, this.y];\r\n                            currentVel = [this.dx, this.dy];\r\n                        }\r\n                        iterations = 0;\r\n                        \r\n                        if(reverseMultiplier < 0){\r\n                            break;\r\n                        }\r\n\r\n                        reverseMultiplier = -1;\r\n                        console.log('reverse');\r\n                    }\r\n\r\n                }\r\n\r\n                \r\n                \r\n                //Call scaling method\r\n                for(let i = 0; i < 5; i++){  \r\n                    this.scaleCanvas();\r\n                }\r\n                resize();\r\n                \r\n                newPath = false;\r\n\r\n\r\n                //Find max radius of path\r\n                let maxRadius = 0;\r\n                let minRadius = 10000000;\r\n                \r\n                if(this.newCoords.length > 0){\r\n                    for(let i = 0; i <this.newCoords.length; i++){\r\n                        let dist = Math.pow(Math.pow(this.newCoords[i][0],2)+Math.pow(this.newCoords[i][1],2),0.5);\r\n                        if(dist > maxRadius){\r\n                            maxRadius = dist;\r\n                        }\r\n                        if(dist < minRadius){\r\n                            minRadius = dist;\r\n                        }\r\n                    }\r\n                } else {\r\n                    for(let i = 0; i <this.pathCoords.length; i++){\r\n                        let dist = Math.pow(Math.pow(this.pathCoords[i][0],2)+Math.pow(this.pathCoords[i][1],2),0.5);\r\n                        if(dist > maxRadius){\r\n                            maxRadius = dist;\r\n                        }\r\n                        if(dist < minRadius){\r\n                            minRadius = dist;\r\n                        }\r\n                    }\r\n                }\r\n            \r\n                vm.$emit('path-update', [currentPos, currentVel, maxRadius, minRadius]);\r\n            }\r\n\r\n            this.scaleCanvas = function() {\r\n                // Scaling\r\n                let maxX = this.pathCoords[0][0];\r\n                let maxY = this.pathCoords[0][1];\r\n                let minX = this.pathCoords[0][0];\r\n                let minY = this.pathCoords[0][1];\r\n\r\n                if(this.newCoords.length > 0){\r\n                    maxX = this.newCoords[0][0];\r\n                    maxY = this.newCoords[0][1];\r\n                    minX = this.newCoords[0][0];\r\n                    minY = this.newCoords[0][1];\r\n\r\n                    for (let i = 0; i < this.newCoords.length; i++) {\r\n                        let coord = this.newCoords[i]\r\n\r\n                        if (coord[0] > maxX) {\r\n                            maxX = coord[0];\r\n                        }\r\n                        else if (coord[0] < minX) {\r\n                            minX = coord[0];\r\n                        }\r\n\r\n                        if (coord[1] > maxY) {\r\n                            maxY = coord[1];\r\n                        }\r\n                        else if (coord[1] < minY) {\r\n                            minY = coord[1];\r\n                        }\r\n                    }\r\n                } else{\r\n                    maxX = this.pathCoords[0][0];\r\n                    maxY = this.pathCoords[0][1];\r\n                    minX = this.pathCoords[0][0];\r\n                    minY = this.pathCoords[0][1];\r\n\r\n                    for (let i = 0; i < this.pathCoords.length; i++) {\r\n                        let coord = this.pathCoords[i]\r\n\r\n                        if (coord[0] > maxX) {\r\n                            maxX = coord[0];\r\n                        }\r\n                        else if (coord[0] < minX) {\r\n                            minX = coord[0];\r\n                        }\r\n\r\n                        if (coord[1] > maxY) {\r\n                            maxY = coord[1];\r\n                        }\r\n                        else if (coord[1] < minY) {\r\n                            minY = coord[1];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(maxX < canvas.width*(1/this.scale)/4 && maxY < canvas.height*(1/this.scale)/4 && minX > -canvas.width*(1/this.scale)/4 && minY > -canvas.height*(1/this.scale)/4){\r\n                    //console.log('downsize', maxX, minX, canvas.width*(1/this.scale)/4, maxY, minY, canvas.height*(1/this.scale)/4);\r\n                    //unscale\r\n                    c.scale((1/this.scale), (1/this.scale));\r\n                    // c.translate(canvas.width/4, canvas.height/4);\r\n                    this.scale = this.scale*2;\r\n                    //c.scale(this.scale, this.scale); rescale done by resize()\r\n                }else if(maxX > canvas.width*(1/this.scale)/2 || maxY > canvas.height*(1/this.scale)/2 || minX < -canvas.width*(1/this.scale)/2 || minY < -canvas.height*(1/this.scale)/2){\r\n                    //console.log('upsize', maxX, minX, canvas.width*(1/this.scale)/4, maxY, minY, canvas.height*(1/this.scale)/4);\r\n                    //unscale\r\n                    c.scale((1/this.scale), (1/this.scale));\r\n                    // c.translate(canvas.width/4, canvas.height/4);\r\n                    this.scale = this.scale/2;\r\n                    //c.scale(this.scale, this.scale); rescale done by resize()\r\n                }\r\n                \r\n                scale = this.scale;\r\n                resize();\r\n            }\r\n\r\n            this.draw = function() {\r\n                this.radius = defaultRadius*(1/this.scale);\r\n                let arrowOffset = this.radius*3;\r\n\r\n                c.beginPath();\r\n                c.moveTo(this.pathCoords[0][0], this.pathCoords[0][1]);\r\n                for(let i = 1; i < this.pathCoords.length; i++){\r\n                    c.lineTo(this.pathCoords[i][0], this.pathCoords[i][1]);\r\n                }\r\n                if(this.closedPath){\r\n                    c.lineTo(this.pathCoords[0][0], this.pathCoords[0][1]);\r\n                }\r\n                c.lineWidth = 2*(1/this.scale);\r\n                c.strokeStyle = \"black\";\r\n                c.stroke();\r\n\r\n                if(this.velocitySelect && this.newCoords.length > 0){\r\n                    c.beginPath();\r\n                    c.moveTo(this.newCoords[0][0], this.newCoords[0][1]);\r\n                    for(let i = 1; i < this.newCoords.length; i++){\r\n                        c.lineTo(this.newCoords[i][0], this.newCoords[i][1]);\r\n                    }\r\n                    if(this.closedPath){\r\n                        c.lineTo(this.newCoords[0][0], this.newCoords[0][1]);\r\n                    }\r\n                    c.lineWidth = 2*(1/this.scale);\r\n                    c.strokeStyle = \"blue\";\r\n                    c.stroke();\r\n                }\r\n\r\n                c.beginPath();\r\n                c.arc(this.x, this.y, this.radius, 0, 2*Math.PI);\r\n                c.fillStyle = 'rgb(0,0,255)';\r\n                c.fill();\r\n                \r\n                if(this.velocitySelect){\r\n                    c.beginPath();\r\n                    c.arc(this.x, this.y, this.radius*1.5, 0, 2*Math.PI);\r\n                    c.fillStyle = 'rgb(0,255,0)';\r\n                    c.fill();\r\n\r\n                    this.tanAngle = Math.atan2(this.pathCoords[this.pathIndex+1][1]- this.pathCoords[this.pathIndex-1][1], this.pathCoords[this.pathIndex+1][0]- this.pathCoords[this.pathIndex-1][0]);\r\n\r\n                    this.arrowCentres = [];\r\n                    for(let i = 0; i < 4; i++){\r\n                        this.arrowCentres.push([this.x + this.radius*4*Math.cos(this.tanAngle + i*Math.PI/2), this.y + this.radius*4*Math.sin(this.tanAngle + i*Math.PI/2)]);\r\n                    }\r\n\r\n                    this.tanPoints1 = rotateShape(this.tanAngle, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n                    this.tanPoints2 = rotateShape(this.tanAngle + Math.PI, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n                    this.rotPoints1 = rotateShape(this.tanAngle + Math.PI/2, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n                    this.rotPoints2 = rotateShape(this.tanAngle + 3*Math.PI/2, [this.x, this.y], [[arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius], [this.radius*2+arrowOffset, this.radius*2], [this.radius*3+arrowOffset, 0],\r\n                    [this.radius*2+arrowOffset, -this.radius*2], [this.radius*2+arrowOffset, -this.radius], [arrowOffset, -this.radius]]);\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.tanPoints1[0][0], this.tanPoints1[0][1]);\r\n                    for(let i = 1; i < this.tanPoints1.length; i++){\r\n                        c.lineTo(this.tanPoints1[i][0], this.tanPoints1[i][1]);\r\n                    }\r\n                    c.fillStyle = 'blue';\r\n                    c.fill();\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.tanPoints2[0][0], this.tanPoints2[0][1]);\r\n                    for(let i = 1; i < this.tanPoints2.length; i++){\r\n                        c.lineTo(this.tanPoints2[i][0], this.tanPoints2[i][1]);\r\n                    }\r\n                    c.fillStyle = 'blue';\r\n                    c.fill();\r\n\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.rotPoints1[0][0], this.rotPoints1[0][1]);\r\n                    for(let i = 1; i < this.rotPoints1.length; i++){\r\n                        c.lineTo(this.rotPoints1[i][0], this.rotPoints1[i][1]);\r\n                    }\r\n                    c.fillStyle = 'purple';\r\n                    c.fill();\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.rotPoints2[0][0], this.rotPoints2[0][1]);\r\n                    for(let i = 1; i < this.rotPoints2.length; i++){\r\n                        c.lineTo(this.rotPoints2[i][0], this.rotPoints2[i][1]);\r\n                    }\r\n                    c.fillStyle = 'purple';\r\n                    c.fill();\r\n                }\r\n\r\n                if(vm.touchSelect){\r\n                    // let dispX = currentTouchX - initialTouchX;\r\n                    // let dispY = currentTouchY - initialTouchY;\r\n                    this.mag = Math.pow(Math.pow(currentTouchX- this.x, 2) + Math.pow(currentTouchY-this.y, 2), 0.5);\r\n                    if(this.mag > this.radius*20){\r\n                        this.mag = this.radius*20;\r\n                    }\r\n\r\n                    this.arrowAngle = Math.atan2(currentTouchY - this.y, currentTouchX - this.x);\r\n\r\n                    this.arrowPoints = rotateShape(this.arrowAngle, [this.x, this.y], [[0,0], [this.mag, this.radius*2], [this.mag, this.radius*6], [this.mag + this.radius*6, 0],[this.mag, -this.radius*6] ,[this.mag, -this.radius*2]]);\r\n\r\n                    c.beginPath();\r\n                    c.moveTo(this.x, this.y);\r\n                    for(let i = 0; i < this.arrowPoints.length; i++){\r\n                        c.lineTo(this.arrowPoints[i][0], this.arrowPoints[i][1]);\r\n                    }\r\n                    c.fillStyle = 'rgba(0, 255, 0, 0.7)';\r\n                    c.fill();\r\n\r\n                    this.arrowConfirmed = true;\r\n                }\r\n            }\r\n\r\n            this.update = function() {\r\n\r\n                this.timeSinceClick += 1; \r\n                this.draw();\r\n\r\n                if(this.pathIndex >= this.pathCoords.length){\r\n                    this.pathIndex=1;\r\n                }\r\n                \r\n                if(!this.velocitySelect && !vm.touchSelect){\r\n                    this.x = this.pathCoords[this.pathIndex][0];\r\n                    this.y = this.pathCoords[this.pathIndex][1];\r\n                    this.dx = this.pathVels[this.pathIndex][0];\r\n                    this.dy = this.pathVels[this.pathIndex][1];\r\n                    this.pathIndex += vm.animationSpeed;\r\n                    vm.$emit('position-update', [this.x, this.y]);\r\n                }\r\n                \r\n                if(vm.velocitySelect && Math.pow((Math.pow((mouseX-this.x),2) + Math.pow((mouseY-this.y),2)),1/2) < this.radius*1.5 && this.timeSinceClick > 20){\r\n                    if(this.velocitySelect && this.newCoords.length > 0){\r\n                        this.pathCoords = this.newCoords;\r\n                        this.pathVels = this.newVels;\r\n                        this.newCoords = [];\r\n                        this.newVels = [];\r\n                        this.pathIndex = 1; \r\n                    }\r\n\r\n                    this.timeSinceClick = 0;\r\n                    this.velocitySelect = !this.velocitySelect;\r\n                }\r\n                \r\n                if(this.velocitySelect){\r\n                    // if(ballArray.length = 1){\r\n                    //     ballArray.push(new Ball(canvas.width/3, canvas.height/3, 10, undefined, undefined));\r\n                    //     //console.log(ballArray);\r\n                    // }\r\n                    for(let i = 0; i < this.arrowCentres.length; i++){\r\n                        if(vm.velocitySelect && Math.pow((Math.pow((mouseX-this.arrowCentres[i][0]),2) + Math.pow((mouseY-this.arrowCentres[i][1]),2)),1/2) < this.radius*2 && this.timeSinceClick > 20){\r\n                            this.timeSinceClick = 0;\r\n                            if(i == 0){\r\n                                console.log('tangential out'); \r\n                                this.newdx += this.buttonStep * Math.cos(this.tanAngle);\r\n                                this.newdy += this.buttonStep * Math.sin(this.tanAngle);\r\n                            }\r\n                            if(i == 1){\r\n                                console.log('radial in');\r\n                                this.newdx += this.buttonStep * Math.sin(this.tanAngle);\r\n                                this.newdy += this.buttonStep * Math.cos(this.tanAngle);\r\n                            }\r\n                            if(i == 2){\r\n                                console.log('tangential in');\r\n                                this.newdx += -this.buttonStep * Math.cos(this.tanAngle);\r\n                                this.newdy += -this.buttonStep * Math.sin(this.tanAngle);\r\n                            }\r\n                            if(i == 3){\r\n                                console.log('radial out');\r\n                                this.newdx += -this.buttonStep * Math.sin(this.tanAngle);\r\n                                this.newdy += -this.buttonStep * Math.cos(this.tanAngle);\r\n                            }\r\n                            console.log('arrow Press');\r\n                            this.path(this.newdx, this.newdy);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.newdx = this.dx;\r\n                    this.newdy = this.dy;\r\n                }\r\n\r\n                //Change velocity and draw new path when touch released\r\n                if(!vm.touchSelect && this.arrowConfirmed){\r\n                    this.newdx = this.dx + (Math.cos(this.arrowAngle)) * (0.0005*this.mag/this.radius*20);\r\n                    this.newdy = this.dy + (Math.sin(this.arrowAngle)) * (0.0005*this.mag/this.radius*20);\r\n                    \r\n                    newPath = true;\r\n                    this.newCoords = [];\r\n                    this.newVels = [];\r\n                    this.path(this.newdx, this.newdy);;\r\n\r\n                    if(this.newCoords.length > 0){\r\n                        this.pathCoords = this.newCoords;\r\n                        this.pathVels = this.newVels;\r\n                        if(this.closedPath){\r\n                            this.pathIndex = 1; \r\n                        } else{\r\n                            this.pathIndex = Math.round(this.pathCoords.length/2);\r\n                        }\r\n                    }\r\n\r\n                    this.arrowConfirmed = false;\r\n                }\r\n            }\r\n        }\r\n        \r\n        //let maxRadius = 30;\r\n        //let mouseRadius = 55;\r\n        let ballArray = [];\r\n\r\n        // [[x,y, mass]]\r\n        //let massCentres = [[canvas.width/3, canvas.height/3], [2*canvas.width/3, canvas.height/3], [canvas.width/2, 2*canvas.height/3]];\r\n        let massCentres = [[0, 0 , 100]];\r\n        let initialVel = 1;\r\n\r\n        ballArray.push(new Ball(canvas.width/3, canvas.height/3, 5, undefined, undefined));\r\n        for(let i = 0; i < ballArray.length; i++){\r\n            ballArray[i].path();\r\n        }\r\n\r\n        function animate() {\r\n            requestAnimationFrame(animate);\r\n\r\n            for (let i = 0; i < ballArray.length; i++){\r\n\r\n                // If statement fixes bug of rect not fully clearing when scale small\r\n                if(1/ballArray[i].scale >= 1){\r\n                c.clearRect(-canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2, canvas.width*(1/ballArray[i].scale), canvas.height*(1/ballArray[i].scale));\r\n                } else{\r\n                    c.clearRect(-canvas.width/2, -canvas.height/2, canvas.width, canvas.height);\r\n                }\r\n                \r\n                //bounding box\r\n                // c.beginPath();\r\n                // c.moveTo(-canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2);\r\n                // c.lineTo(canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2);\r\n                // c.lineTo(canvas.width*(1/ballArray[i].scale)/2, canvas.height*(1/ballArray[i].scale)/2);\r\n                // c.lineTo(-canvas.width*(1/ballArray[i].scale)/2, canvas.height*(1/ballArray[i].scale)/2);\r\n                // c.lineTo(-canvas.width*(1/ballArray[i].scale)/2, -canvas.height*(1/ballArray[i].scale)/2);\r\n                // c.lineWidth = 1;\r\n                // c.stroke();\r\n            }\r\n\r\n            mouseX = (vm.mouse.x - rect.left)*(1/ballArray[0].scale) - canvas.width/2;\r\n            mouseY = (vm.mouse.y - rect.top )*(1/ballArray[0].scale) - canvas.height/2;\r\n            currentTouchX = (vm.currentTouchPos.x - rect.left)*(1/ballArray[0].scale) - canvas.width/2;\r\n            currentTouchY = (vm.currentTouchPos.y - rect.top)*(1/ballArray[0].scale) - canvas.height/2;\r\n            // initialTouchX = (vm.initialTouchPos.x - rect.left - canvas.width/2)*(1/ballArray[0].scale);\r\n            // initialTouchY = (vm.initialTouchPos.y - rect.top - canvas.height/2)*(1/ballArray[0].scale);\r\n\r\n            for (let i = 0; i < ballArray.length; i++){\r\n                ballArray[i].update();\r\n            }\r\n\r\n            for (let i = 0; i <massCentres.length; i++){\r\n                c.beginPath();\r\n                c.arc(massCentres[i][0], massCentres[i][1], vm.sunRadius, 0, Math.PI * 2); \r\n                c.fillStyle = 'Orange';\r\n                c.fill();\r\n            }\r\n\r\n            // c.beginPath();\r\n            // c.arc(mouseX, mouseY, 20, 0, Math.PI * 2);\r\n            // c.fillStyle = \"black\";\r\n            // c.fill();\r\n            \r\n            // c.beginPath();\r\n            // c.arc(2316, 669, 500, 0, Math.PI * 2); \r\n            // c.fillStyle = 'Red';\r\n            // c.fill();\r\n            \r\n        }\r\n\r\n        animate();\r\n\r\n    }\r\n\r\n}\r\n</script>\r\n\r\n<style>\r\n#front-animation{\r\n    /* border: 1px solid black; */\r\n}\r\n</style>"]}]}